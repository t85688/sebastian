/******************************************************************************
** moxaclassbased_datatypes.h
**
**   **************************** auto-generated ****************************
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.8.0, using C++ OPC UA SDK 1.8.2 template (version 4)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
**   **************************** auto-generated ****************************
**
** Copyright (c) 2006-2025 Unified Automation GmbH. All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
** Project: C++ OPC Server SDK information model for namespace http://www.moxa.com/auto-configuration-tool-class-based-model/
**
** Description: OPC Unified Architecture Software Development Kit.
**
******************************************************************************/

#ifndef __MOXACLASSBASED_DATATYPES_H__
#define __MOXACLASSBASED_DATATYPES_H__

#include <opcua_proxystub.h>
#include <opcua_builtintypes.h>
#include <opcua_exclusions.h>
#include <opcua_types.h>
#include <opcuaclassbnm_datatypes.h>

#include "moxaclassbased_identifiers.h"

#define MOXACLASSBASED_EXTENSIONOBJECT_GET_ENCODEABLE(xExpectedType, xExtensionObject) \
    (MoxaClassBased_##xExpectedType*)((((xExtensionObject)->Encoding == OpcUa_ExtensionObjectEncoding_EncodeableObject && \
    (xExtensionObject)->Body.EncodeableObject.Type != OpcUa_Null && \
    (xExtensionObject)->Body.EncodeableObject.Type->TypeId == MoxaClassBasedId_##xExpectedType && \
    OpcUa_StrCmpA((xExtensionObject)->Body.EncodeableObject.Type->NamespaceUri, "http://www.moxa.com/auto-configuration-tool-class-based-model/") == 0 && \
    (xExtensionObject)->Body.EncodeableObject.Object != OpcUa_Null))?((xExtensionObject)->Body.EncodeableObject.Object):OpcUa_Null)


// Namespace for the UA information model http://www.moxa.com/auto-configuration-tool-class-based-model/
namespace MoxaClassBased {

#ifndef OPCUA_EXCLUDE_ActiveSnmpEnumType
/*============================================================================
 * The ActiveSnmpEnumType enumeration.
 *===========================================================================*/
enum ActiveSnmpEnumType
{
    ActiveSnmpEnumType_Enabled = 1,
    ActiveSnmpEnumType_Disabled = 2,
    ActiveSnmpEnumType_ReadOnly = 3
#if OPCUA_FORCE_INT32_ENUMS
    ,_ActiveSnmpEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void ActiveSnmpEnumType_Clear(ActiveSnmpEnumType *pValue) {*pValue = ActiveSnmpEnumType_Enabled;}

MoxaClassBased_EXPORT inline void ActiveSnmpEnumType_Initialize(ActiveSnmpEnumType *pValue) {*pValue = ActiveSnmpEnumType_Enabled;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType ActiveSnmpEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_ActiveSnmpEnumType*/
#ifndef OPCUA_EXCLUDE_AuthorityEnumType
/*============================================================================
 * The AuthorityEnumType enumeration.
 *===========================================================================*/
enum AuthorityEnumType
{
    AuthorityEnumType_Admin = 0,
    AuthorityEnumType_Supervisor = 1,
    AuthorityEnumType_User = 2
#if OPCUA_FORCE_INT32_ENUMS
    ,_AuthorityEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void AuthorityEnumType_Clear(AuthorityEnumType *pValue) {*pValue = AuthorityEnumType_Admin;}

MoxaClassBased_EXPORT inline void AuthorityEnumType_Initialize(AuthorityEnumType *pValue) {*pValue = AuthorityEnumType_Admin;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType AuthorityEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_AuthorityEnumType*/
#ifndef OPCUA_EXCLUDE_EdgeEnumType
/*============================================================================
 * The EdgeEnumType enumeration.
 *===========================================================================*/
enum EdgeEnumType
{
    EdgeEnumType_Auto = 0,
    EdgeEnumType_Yes = 1,
    EdgeEnumType_No = 2
#if OPCUA_FORCE_INT32_ENUMS
    ,_EdgeEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void EdgeEnumType_Clear(EdgeEnumType *pValue) {*pValue = EdgeEnumType_Auto;}

MoxaClassBased_EXPORT inline void EdgeEnumType_Initialize(EdgeEnumType *pValue) {*pValue = EdgeEnumType_Auto;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType EdgeEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_EdgeEnumType*/
#ifndef OPCUA_EXCLUDE_LinkCableType
/*============================================================================
 * The LinkCableType enumeration.
 *===========================================================================*/
enum LinkCableType
{
    LinkCableType_Copper = 0 /**<Copper*/,
    LinkCableType_Fiber = 1 /**<Fiber*/
#if OPCUA_FORCE_INT32_ENUMS
    ,_LinkCableType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void LinkCableType_Clear(LinkCableType *pValue) {*pValue = LinkCableType_Copper;}

MoxaClassBased_EXPORT inline void LinkCableType_Initialize(LinkCableType *pValue) {*pValue = LinkCableType_Copper;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType LinkCableType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_LinkCableType*/
#ifndef OPCUA_EXCLUDE_LinkTypeEnumType
/*============================================================================
 * The LinkTypeEnumType enumeration.
 *===========================================================================*/
enum LinkTypeEnumType
{
    LinkTypeEnumType_PointToPoint = 0,
    LinkTypeEnumType_Shared = 1,
    LinkTypeEnumType_Auto = 2
#if OPCUA_FORCE_INT32_ENUMS
    ,_LinkTypeEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void LinkTypeEnumType_Clear(LinkTypeEnumType *pValue) {*pValue = LinkTypeEnumType_PointToPoint;}

MoxaClassBased_EXPORT inline void LinkTypeEnumType_Initialize(LinkTypeEnumType *pValue) {*pValue = LinkTypeEnumType_PointToPoint;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType LinkTypeEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_LinkTypeEnumType*/
#ifndef OPCUA_EXCLUDE_PerStreamPriorityModeEnumType
/*============================================================================
 * The PerStreamPriorityModeEnumType enumeration.
 *===========================================================================*/
enum PerStreamPriorityModeEnumType
{
    PerStreamPriorityModeEnumType_L2 = 0,
    PerStreamPriorityModeEnumType_L3TCP = 1,
    PerStreamPriorityModeEnumType_L3UDP = 2
#if OPCUA_FORCE_INT32_ENUMS
    ,_PerStreamPriorityModeEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void PerStreamPriorityModeEnumType_Clear(PerStreamPriorityModeEnumType *pValue) {*pValue = PerStreamPriorityModeEnumType_L2;}

MoxaClassBased_EXPORT inline void PerStreamPriorityModeEnumType_Initialize(PerStreamPriorityModeEnumType *pValue) {*pValue = PerStreamPriorityModeEnumType_L2;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType PerStreamPriorityModeEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_PerStreamPriorityModeEnumType*/
#ifndef OPCUA_EXCLUDE_PortModeEnumType
/*============================================================================
 * The PortModeEnumType enumeration.
 *===========================================================================*/
enum PortModeEnumType
{
    PortModeEnumType_Access = 0,
    PortModeEnumType_Trunk = 1,
    PortModeEnumType_Hybrid = 2
#if OPCUA_FORCE_INT32_ENUMS
    ,_PortModeEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void PortModeEnumType_Clear(PortModeEnumType *pValue) {*pValue = PortModeEnumType_Access;}

MoxaClassBased_EXPORT inline void PortModeEnumType_Initialize(PortModeEnumType *pValue) {*pValue = PortModeEnumType_Access;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType PortModeEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_PortModeEnumType*/
#ifndef OPCUA_EXCLUDE_ProfileEnumType
/*============================================================================
 * The ProfileEnumType enumeration.
 *===========================================================================*/
enum ProfileEnumType
{
    ProfileEnumType_IEEE_802Dot1AS_2011 = 0,
    ProfileEnumType_NotSupport = 1
#if OPCUA_FORCE_INT32_ENUMS
    ,_ProfileEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void ProfileEnumType_Clear(ProfileEnumType *pValue) {*pValue = ProfileEnumType_IEEE_802Dot1AS_2011;}

MoxaClassBased_EXPORT inline void ProfileEnumType_Initialize(ProfileEnumType *pValue) {*pValue = ProfileEnumType_IEEE_802Dot1AS_2011;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType ProfileEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_ProfileEnumType*/
#ifndef OPCUA_EXCLUDE_QoSEnumType
/*============================================================================
 * The QoSEnumType enumeration.
 *===========================================================================*/
enum QoSEnumType
{
    QoSEnumType_Bandwidth = 0,
    QoSEnumType_BoundedLatency = 1,
    QoSEnumType_Deadline = 2
#if OPCUA_FORCE_INT32_ENUMS
    ,_QoSEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void QoSEnumType_Clear(QoSEnumType *pValue) {*pValue = QoSEnumType_Bandwidth;}

MoxaClassBased_EXPORT inline void QoSEnumType_Initialize(QoSEnumType *pValue) {*pValue = QoSEnumType_Bandwidth;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType QoSEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_QoSEnumType*/
#ifndef OPCUA_EXCLUDE_SNMPTrapModeEnumType
/*============================================================================
 * The SNMPTrapModeEnumType enumeration.
 *===========================================================================*/
enum SNMPTrapModeEnumType
{
    SNMPTrapModeEnumType_TrapV1 = 0,
    SNMPTrapModeEnumType_TrapV2c = 1,
    SNMPTrapModeEnumType_InformV2c = 2,
    SNMPTrapModeEnumType_NotSupport = 3
#if OPCUA_FORCE_INT32_ENUMS
    ,_SNMPTrapModeEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void SNMPTrapModeEnumType_Clear(SNMPTrapModeEnumType *pValue) {*pValue = SNMPTrapModeEnumType_TrapV1;}

MoxaClassBased_EXPORT inline void SNMPTrapModeEnumType_Initialize(SNMPTrapModeEnumType *pValue) {*pValue = SNMPTrapModeEnumType_TrapV1;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType SNMPTrapModeEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_SNMPTrapModeEnumType*/
#ifndef OPCUA_EXCLUDE_SNMPVersion
/*============================================================================
 * The SNMPVersion enumeration.
 *===========================================================================*/
enum SNMPVersion
{
    SNMPVersion_v2c = 1 /**<SNMP Version 2c*/
#if OPCUA_FORCE_INT32_ENUMS
    ,_SNMPVersion_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void SNMPVersion_Clear(SNMPVersion *pValue) {*pValue = SNMPVersion_v2c;}

MoxaClassBased_EXPORT inline void SNMPVersion_Initialize(SNMPVersion *pValue) {*pValue = SNMPVersion_v2c;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType SNMPVersion_EnumeratedType;

#endif /*OPCUA_EXCLUDE_SNMPVersion*/
#ifndef OPCUA_EXCLUDE_SpanningTreeCompatibilityEnumType
/*============================================================================
 * The SpanningTreeCompatibilityEnumType enumeration.
 *===========================================================================*/
enum SpanningTreeCompatibilityEnumType
{
    SpanningTreeCompatibilityEnumType_STP = 0,
    SpanningTreeCompatibilityEnumType_RSTP = 1,
    SpanningTreeCompatibilityEnumType_NotSupport = 2
#if OPCUA_FORCE_INT32_ENUMS
    ,_SpanningTreeCompatibilityEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void SpanningTreeCompatibilityEnumType_Clear(SpanningTreeCompatibilityEnumType *pValue) {*pValue = SpanningTreeCompatibilityEnumType_STP;}

MoxaClassBased_EXPORT inline void SpanningTreeCompatibilityEnumType_Initialize(SpanningTreeCompatibilityEnumType *pValue) {*pValue = SpanningTreeCompatibilityEnumType_STP;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType SpanningTreeCompatibilityEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_SpanningTreeCompatibilityEnumType*/
#ifndef OPCUA_EXCLUDE_TagMethodEnumType
/*============================================================================
 * The TagMethodEnumType enumeration.
 *===========================================================================*/
enum TagMethodEnumType
{
    TagMethodEnumType_PerStreamPriority = 0
#if OPCUA_FORCE_INT32_ENUMS
    ,_TagMethodEnumType_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void TagMethodEnumType_Clear(TagMethodEnumType *pValue) {*pValue = TagMethodEnumType_PerStreamPriority;}

MoxaClassBased_EXPORT inline void TagMethodEnumType_Initialize(TagMethodEnumType *pValue) {*pValue = TagMethodEnumType_PerStreamPriority;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType TagMethodEnumType_EnumeratedType;

#endif /*OPCUA_EXCLUDE_TagMethodEnumType*/
#ifndef OPCUA_EXCLUDE_TransportProtocol
/*============================================================================
 * The TransportProtocol enumeration.
 *===========================================================================*/
enum TransportProtocol
{
    TransportProtocol_UDP = 0 /**<UDP*/,
    TransportProtocol_TCP = 1 /**<TCP*/
#if OPCUA_FORCE_INT32_ENUMS
    ,_TransportProtocol_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

MoxaClassBased_EXPORT inline void TransportProtocol_Clear(TransportProtocol *pValue) {*pValue = TransportProtocol_UDP;}

MoxaClassBased_EXPORT inline void TransportProtocol_Initialize(TransportProtocol *pValue) {*pValue = TransportProtocol_UDP;}

MoxaClassBased_EXPORT extern struct ::_OpcUa_EnumeratedType TransportProtocol_EnumeratedType;

#endif /*OPCUA_EXCLUDE_TransportProtocol*/
}

#ifndef OPCUA_EXCLUDE_MoxaClassBased_ConnectionAccountDataType
/*============================================================================
 * The MoxaClassBased_ConnectionAccountDataType structure.
 *===========================================================================*/
enum MoxaClassBased_ConnectionAccountDataType_OptionalFields
{
    MoxaClassBased_ConnectionAccountDataType_OptionalFields_UserName = 1,
    MoxaClassBased_ConnectionAccountDataType_OptionalFields_Password = 2
};

typedef struct _MoxaClassBased_ConnectionAccountDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String UserName;
    OpcUa_String Password;
} MoxaClassBased_ConnectionAccountDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_ConnectionAccountDataType_Initialize(MoxaClassBased_ConnectionAccountDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_ConnectionAccountDataType_Clear(MoxaClassBased_ConnectionAccountDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ConnectionAccountDataType_GetSize(MoxaClassBased_ConnectionAccountDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ConnectionAccountDataType_Encode(MoxaClassBased_ConnectionAccountDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ConnectionAccountDataType_Decode(MoxaClassBased_ConnectionAccountDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_ConnectionAccountDataType_Compare(const MoxaClassBased_ConnectionAccountDataType* pValue1, const MoxaClassBased_ConnectionAccountDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ConnectionAccountDataType_Copy(const MoxaClassBased_ConnectionAccountDataType* pSource, MoxaClassBased_ConnectionAccountDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ConnectionAccountDataType_CopyTo(const MoxaClassBased_ConnectionAccountDataType* pSource, MoxaClassBased_ConnectionAccountDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_ConnectionAccountDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_ConnectionAccountDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_DeviceAccountDataType
/*============================================================================
 * The MoxaClassBased_DeviceAccountDataType structure.
 *===========================================================================*/
enum MoxaClassBased_DeviceAccountDataType_OptionalFields
{
    MoxaClassBased_DeviceAccountDataType_OptionalFields_Password = 1,
    MoxaClassBased_DeviceAccountDataType_OptionalFields_Authority = 2,
    MoxaClassBased_DeviceAccountDataType_OptionalFields_Email = 4,
    MoxaClassBased_DeviceAccountDataType_OptionalFields_SyncToConnectionAccount = 8
};

typedef struct _MoxaClassBased_DeviceAccountDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String UserName;
    OpcUa_String Password;
    MoxaClassBased::AuthorityEnumType Authority;
    OpcUa_String Email;
    OpcUa_Boolean SyncToConnectionAccount;
} MoxaClassBased_DeviceAccountDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_DeviceAccountDataType_Initialize(MoxaClassBased_DeviceAccountDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_DeviceAccountDataType_Clear(MoxaClassBased_DeviceAccountDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceAccountDataType_GetSize(MoxaClassBased_DeviceAccountDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceAccountDataType_Encode(MoxaClassBased_DeviceAccountDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceAccountDataType_Decode(MoxaClassBased_DeviceAccountDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_DeviceAccountDataType_Compare(const MoxaClassBased_DeviceAccountDataType* pValue1, const MoxaClassBased_DeviceAccountDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceAccountDataType_Copy(const MoxaClassBased_DeviceAccountDataType* pSource, MoxaClassBased_DeviceAccountDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceAccountDataType_CopyTo(const MoxaClassBased_DeviceAccountDataType* pSource, MoxaClassBased_DeviceAccountDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_DeviceAccountDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_DeviceAccountDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_DiscoveredDeviceDataType
/*============================================================================
 * The MoxaClassBased_DiscoveredDeviceDataType structure.
 *===========================================================================*/
typedef struct _MoxaClassBased_DiscoveredDeviceDataType
{
    OpcUa_String OriginalIpAddress;
    OpcUa_String NewAssignedIpAddress;
    OpcUa_String MacAddress;
    OpcUa_Boolean SNMPConnected;
    OpcUa_Boolean RESTfulConnected;
    OpcUa_UInt32 HopCount;
} MoxaClassBased_DiscoveredDeviceDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_DiscoveredDeviceDataType_Initialize(MoxaClassBased_DiscoveredDeviceDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_DiscoveredDeviceDataType_Clear(MoxaClassBased_DiscoveredDeviceDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DiscoveredDeviceDataType_GetSize(MoxaClassBased_DiscoveredDeviceDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DiscoveredDeviceDataType_Encode(MoxaClassBased_DiscoveredDeviceDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DiscoveredDeviceDataType_Decode(MoxaClassBased_DiscoveredDeviceDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_DiscoveredDeviceDataType_Compare(const MoxaClassBased_DiscoveredDeviceDataType* pValue1, const MoxaClassBased_DiscoveredDeviceDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DiscoveredDeviceDataType_Copy(const MoxaClassBased_DiscoveredDeviceDataType* pSource, MoxaClassBased_DiscoveredDeviceDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DiscoveredDeviceDataType_CopyTo(const MoxaClassBased_DiscoveredDeviceDataType* pSource, MoxaClassBased_DiscoveredDeviceDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_DiscoveredDeviceDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_DiscoveredDeviceDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_GateControlDataType
/*============================================================================
 * The MoxaClassBased_GateControlDataType structure.
 *===========================================================================*/
enum MoxaClassBased_GateControlDataType_OptionalFields
{
    MoxaClassBased_GateControlDataType_OptionalFields_Interval = 1
};

typedef struct _MoxaClassBased_GateControlDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_Int64 Index;
    OpcUa_Int64 Interval;
    OpcUa_Boolean Queue0;
    OpcUa_Boolean Queue1;
    OpcUa_Boolean Queue2;
    OpcUa_Boolean Queue3;
    OpcUa_Boolean Queue4;
    OpcUa_Boolean Queue5;
    OpcUa_Boolean Queue6;
    OpcUa_Boolean Queue7;
} MoxaClassBased_GateControlDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_GateControlDataType_Initialize(MoxaClassBased_GateControlDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_GateControlDataType_Clear(MoxaClassBased_GateControlDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_GateControlDataType_GetSize(MoxaClassBased_GateControlDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_GateControlDataType_Encode(MoxaClassBased_GateControlDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_GateControlDataType_Decode(MoxaClassBased_GateControlDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_GateControlDataType_Compare(const MoxaClassBased_GateControlDataType* pValue1, const MoxaClassBased_GateControlDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_GateControlDataType_Copy(const MoxaClassBased_GateControlDataType* pSource, MoxaClassBased_GateControlDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_GateControlDataType_CopyTo(const MoxaClassBased_GateControlDataType* pSource, MoxaClassBased_GateControlDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_GateControlDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_GateControlDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType
/*============================================================================
 * The MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType structure.
 *===========================================================================*/
typedef struct _MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType
{
    OpcUa_UInt16 MaxIntervalFrames;
    OpcUa_UInt32 MaxFrameSize;
    OpcUaClassBnm_UnsignedRationalNumber Interval;
} MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType_Initialize(MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType_Clear(MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType_GetSize(MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType_Encode(MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType_Decode(MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType_Compare(const MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pValue1, const MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType_Copy(const MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pSource, MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType_CopyTo(const MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pSource, MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_IeeeBaseTsnTrafficSpecificationDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_TsnTrafficSpecificationDataType
/*============================================================================
 * The MoxaClassBased_TsnTrafficSpecificationDataType structure.
 *===========================================================================*/
typedef struct _MoxaClassBased_TsnTrafficSpecificationDataType
{
    OpcUa_UInt16 MaxIntervalFrames;
    OpcUa_UInt32 MaxFrameSize;
    OpcUaClassBnm_UnsignedRationalNumber Interval;
    OpcUa_UInt32 MaxBytesPerInterval;
} MoxaClassBased_TsnTrafficSpecificationDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnTrafficSpecificationDataType_Initialize(MoxaClassBased_TsnTrafficSpecificationDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnTrafficSpecificationDataType_Clear(MoxaClassBased_TsnTrafficSpecificationDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnTrafficSpecificationDataType_GetSize(MoxaClassBased_TsnTrafficSpecificationDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnTrafficSpecificationDataType_Encode(MoxaClassBased_TsnTrafficSpecificationDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnTrafficSpecificationDataType_Decode(MoxaClassBased_TsnTrafficSpecificationDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_TsnTrafficSpecificationDataType_Compare(const MoxaClassBased_TsnTrafficSpecificationDataType* pValue1, const MoxaClassBased_TsnTrafficSpecificationDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnTrafficSpecificationDataType_Copy(const MoxaClassBased_TsnTrafficSpecificationDataType* pSource, MoxaClassBased_TsnTrafficSpecificationDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnTrafficSpecificationDataType_CopyTo(const MoxaClassBased_TsnTrafficSpecificationDataType* pSource, MoxaClassBased_TsnTrafficSpecificationDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_TsnTrafficSpecificationDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_TsnTrafficSpecificationDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_IeeeDot1AS2011DataType
/*============================================================================
 * The MoxaClassBased_IeeeDot1AS2011DataType structure.
 *===========================================================================*/
enum MoxaClassBased_IeeeDot1AS2011DataType_OptionalFields
{
    MoxaClassBased_IeeeDot1AS2011DataType_OptionalFields_Priority1 = 1,
    MoxaClassBased_IeeeDot1AS2011DataType_OptionalFields_Priority2 = 2,
    MoxaClassBased_IeeeDot1AS2011DataType_OptionalFields_AccuracyAlert = 4
};

typedef struct _MoxaClassBased_IeeeDot1AS2011DataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_UInt16 Priority1;
    OpcUa_UInt16 Priority2;
    OpcUa_UInt64 AccuracyAlert;
} MoxaClassBased_IeeeDot1AS2011DataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IeeeDot1AS2011DataType_Initialize(MoxaClassBased_IeeeDot1AS2011DataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IeeeDot1AS2011DataType_Clear(MoxaClassBased_IeeeDot1AS2011DataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011DataType_GetSize(MoxaClassBased_IeeeDot1AS2011DataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011DataType_Encode(MoxaClassBased_IeeeDot1AS2011DataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011DataType_Decode(MoxaClassBased_IeeeDot1AS2011DataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_IeeeDot1AS2011DataType_Compare(const MoxaClassBased_IeeeDot1AS2011DataType* pValue1, const MoxaClassBased_IeeeDot1AS2011DataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011DataType_Copy(const MoxaClassBased_IeeeDot1AS2011DataType* pSource, MoxaClassBased_IeeeDot1AS2011DataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011DataType_CopyTo(const MoxaClassBased_IeeeDot1AS2011DataType* pSource, MoxaClassBased_IeeeDot1AS2011DataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_IeeeDot1AS2011DataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_IeeeDot1AS2011DataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_IeeeDot1AS2011PortDataType
/*============================================================================
 * The MoxaClassBased_IeeeDot1AS2011PortDataType structure.
 *===========================================================================*/
enum MoxaClassBased_IeeeDot1AS2011PortDataType_OptionalFields
{
    MoxaClassBased_IeeeDot1AS2011PortDataType_OptionalFields_Active = 1,
    MoxaClassBased_IeeeDot1AS2011PortDataType_OptionalFields_AnnounceInterval = 2,
    MoxaClassBased_IeeeDot1AS2011PortDataType_OptionalFields_AnnounceReceiptTimeout = 4,
    MoxaClassBased_IeeeDot1AS2011PortDataType_OptionalFields_SyncInterval = 8,
    MoxaClassBased_IeeeDot1AS2011PortDataType_OptionalFields_SyncReceiptTimeout = 16,
    MoxaClassBased_IeeeDot1AS2011PortDataType_OptionalFields_PdelayRequestInterval = 32,
    MoxaClassBased_IeeeDot1AS2011PortDataType_OptionalFields_NeighborPropagationDelayThreshold = 64
};

typedef struct _MoxaClassBased_IeeeDot1AS2011PortDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_Boolean Active;
    OpcUa_Int32 AnnounceInterval;
    OpcUa_Int32 AnnounceReceiptTimeout;
    OpcUa_Int32 SyncInterval;
    OpcUa_Int32 SyncReceiptTimeout;
    OpcUa_Int32 PdelayRequestInterval;
    OpcUa_Int32 NeighborPropagationDelayThreshold;
} MoxaClassBased_IeeeDot1AS2011PortDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IeeeDot1AS2011PortDataType_Initialize(MoxaClassBased_IeeeDot1AS2011PortDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IeeeDot1AS2011PortDataType_Clear(MoxaClassBased_IeeeDot1AS2011PortDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011PortDataType_GetSize(MoxaClassBased_IeeeDot1AS2011PortDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011PortDataType_Encode(MoxaClassBased_IeeeDot1AS2011PortDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011PortDataType_Decode(MoxaClassBased_IeeeDot1AS2011PortDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_IeeeDot1AS2011PortDataType_Compare(const MoxaClassBased_IeeeDot1AS2011PortDataType* pValue1, const MoxaClassBased_IeeeDot1AS2011PortDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011PortDataType_Copy(const MoxaClassBased_IeeeDot1AS2011PortDataType* pSource, MoxaClassBased_IeeeDot1AS2011PortDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeDot1AS2011PortDataType_CopyTo(const MoxaClassBased_IeeeDot1AS2011PortDataType* pSource, MoxaClassBased_IeeeDot1AS2011PortDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_IeeeDot1AS2011PortDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_IeeeDot1AS2011PortDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_IeeeTsnVlanTagDataType
/*============================================================================
 * The MoxaClassBased_IeeeTsnVlanTagDataType structure.
 *===========================================================================*/
typedef struct _MoxaClassBased_IeeeTsnVlanTagDataType
{
    OpcUa_UInt16 VlanId;
    OpcUa_Byte PriorityCodePoint;
} MoxaClassBased_IeeeTsnVlanTagDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IeeeTsnVlanTagDataType_Initialize(MoxaClassBased_IeeeTsnVlanTagDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IeeeTsnVlanTagDataType_Clear(MoxaClassBased_IeeeTsnVlanTagDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeTsnVlanTagDataType_GetSize(MoxaClassBased_IeeeTsnVlanTagDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeTsnVlanTagDataType_Encode(MoxaClassBased_IeeeTsnVlanTagDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeTsnVlanTagDataType_Decode(MoxaClassBased_IeeeTsnVlanTagDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_IeeeTsnVlanTagDataType_Compare(const MoxaClassBased_IeeeTsnVlanTagDataType* pValue1, const MoxaClassBased_IeeeTsnVlanTagDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeTsnVlanTagDataType_Copy(const MoxaClassBased_IeeeTsnVlanTagDataType* pSource, MoxaClassBased_IeeeTsnVlanTagDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IeeeTsnVlanTagDataType_CopyTo(const MoxaClassBased_IeeeTsnVlanTagDataType* pSource, MoxaClassBased_IeeeTsnVlanTagDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_IeeeTsnVlanTagDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_IeeeTsnVlanTagDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_IpConfigureDataType
/*============================================================================
 * The MoxaClassBased_IpConfigureDataType structure.
 *===========================================================================*/
typedef struct _MoxaClassBased_IpConfigureDataType
{
    OpcUa_String MacAddress;
    OpcUa_String AssignedIpAddress;
} MoxaClassBased_IpConfigureDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IpConfigureDataType_Initialize(MoxaClassBased_IpConfigureDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IpConfigureDataType_Clear(MoxaClassBased_IpConfigureDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpConfigureDataType_GetSize(MoxaClassBased_IpConfigureDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpConfigureDataType_Encode(MoxaClassBased_IpConfigureDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpConfigureDataType_Decode(MoxaClassBased_IpConfigureDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_IpConfigureDataType_Compare(const MoxaClassBased_IpConfigureDataType* pValue1, const MoxaClassBased_IpConfigureDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpConfigureDataType_Copy(const MoxaClassBased_IpConfigureDataType* pSource, MoxaClassBased_IpConfigureDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpConfigureDataType_CopyTo(const MoxaClassBased_IpConfigureDataType* pSource, MoxaClassBased_IpConfigureDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_IpConfigureDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_IpConfigureDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_IpSettingDataType
/*============================================================================
 * The MoxaClassBased_IpSettingDataType structure.
 *===========================================================================*/
enum MoxaClassBased_IpSettingDataType_OptionalFields
{
    MoxaClassBased_IpSettingDataType_OptionalFields_IpAddress = 1,
    MoxaClassBased_IpSettingDataType_OptionalFields_SubnetMask = 2,
    MoxaClassBased_IpSettingDataType_OptionalFields_Gateway = 4,
    MoxaClassBased_IpSettingDataType_OptionalFields_DNS1 = 8,
    MoxaClassBased_IpSettingDataType_OptionalFields_DNS2 = 16
};

typedef struct _MoxaClassBased_IpSettingDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String IpAddress;
    OpcUa_String SubnetMask;
    OpcUa_String Gateway;
    OpcUa_String DNS1;
    OpcUa_String DNS2;
} MoxaClassBased_IpSettingDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IpSettingDataType_Initialize(MoxaClassBased_IpSettingDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_IpSettingDataType_Clear(MoxaClassBased_IpSettingDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpSettingDataType_GetSize(MoxaClassBased_IpSettingDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpSettingDataType_Encode(MoxaClassBased_IpSettingDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpSettingDataType_Decode(MoxaClassBased_IpSettingDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_IpSettingDataType_Compare(const MoxaClassBased_IpSettingDataType* pValue1, const MoxaClassBased_IpSettingDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpSettingDataType_Copy(const MoxaClassBased_IpSettingDataType* pSource, MoxaClassBased_IpSettingDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_IpSettingDataType_CopyTo(const MoxaClassBased_IpSettingDataType* pSource, MoxaClassBased_IpSettingDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_IpSettingDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_IpSettingDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_LinkDataType
/*============================================================================
 * The MoxaClassBased_LinkDataType structure.
 *===========================================================================*/
typedef struct _MoxaClassBased_LinkDataType
{
    OpcUa_String SourceIpAddress;
    OpcUa_String SourceInterfaceName;
    OpcUa_String DestinationIpAddress;
    OpcUa_String DestinationInterfaceName;
} MoxaClassBased_LinkDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_LinkDataType_Initialize(MoxaClassBased_LinkDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_LinkDataType_Clear(MoxaClassBased_LinkDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_LinkDataType_GetSize(MoxaClassBased_LinkDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_LinkDataType_Encode(MoxaClassBased_LinkDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_LinkDataType_Decode(MoxaClassBased_LinkDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_LinkDataType_Compare(const MoxaClassBased_LinkDataType* pValue1, const MoxaClassBased_LinkDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_LinkDataType_Copy(const MoxaClassBased_LinkDataType* pSource, MoxaClassBased_LinkDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_LinkDataType_CopyTo(const MoxaClassBased_LinkDataType* pSource, MoxaClassBased_LinkDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_LinkDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_LinkDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_ManagementInterfaceDataType
/*============================================================================
 * The MoxaClassBased_ManagementInterfaceDataType structure.
 *===========================================================================*/
enum MoxaClassBased_ManagementInterfaceDataType_OptionalFields
{
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpActive = 1,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpTcpPort = 2,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpsActive = 4,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpsTcpPort = 8,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_TelnetActive = 16,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_TelnetTcpPort = 32,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SshActive = 64,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SshTcpPort = 128,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpActive = 256,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpTransportProtocol = 512,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpPort = 1024,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_NumberOfHttpAndHttpsLoginSessions = 2048,
    MoxaClassBased_ManagementInterfaceDataType_OptionalFields_NumberOfTelnetAndSshLoginSessions = 4096
};

typedef struct _MoxaClassBased_ManagementInterfaceDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_Boolean HttpActive;
    OpcUa_UInt16 HttpTcpPort;
    OpcUa_Boolean HttpsActive;
    OpcUa_UInt16 HttpsTcpPort;
    OpcUa_Boolean TelnetActive;
    OpcUa_UInt16 TelnetTcpPort;
    OpcUa_Boolean SshActive;
    OpcUa_UInt16 SshTcpPort;
    MoxaClassBased::ActiveSnmpEnumType SnmpActive;
    MoxaClassBased::TransportProtocol SnmpTransportProtocol;
    OpcUa_UInt16 SnmpPort;
    OpcUa_UInt16 NumberOfHttpAndHttpsLoginSessions;
    OpcUa_UInt16 NumberOfTelnetAndSshLoginSessions;
} MoxaClassBased_ManagementInterfaceDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_ManagementInterfaceDataType_Initialize(MoxaClassBased_ManagementInterfaceDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_ManagementInterfaceDataType_Clear(MoxaClassBased_ManagementInterfaceDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ManagementInterfaceDataType_GetSize(MoxaClassBased_ManagementInterfaceDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ManagementInterfaceDataType_Encode(MoxaClassBased_ManagementInterfaceDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ManagementInterfaceDataType_Decode(MoxaClassBased_ManagementInterfaceDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_ManagementInterfaceDataType_Compare(const MoxaClassBased_ManagementInterfaceDataType* pValue1, const MoxaClassBased_ManagementInterfaceDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ManagementInterfaceDataType_Copy(const MoxaClassBased_ManagementInterfaceDataType* pSource, MoxaClassBased_ManagementInterfaceDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ManagementInterfaceDataType_CopyTo(const MoxaClassBased_ManagementInterfaceDataType* pSource, MoxaClassBased_ManagementInterfaceDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_ManagementInterfaceDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_ManagementInterfaceDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_NETCONFDataType
/*============================================================================
 * The MoxaClassBased_NETCONFDataType structure.
 *===========================================================================*/
enum MoxaClassBased_NETCONFDataType_OptionalFields
{
    MoxaClassBased_NETCONFDataType_OptionalFields_SSHPort = 1
};

typedef struct _MoxaClassBased_NETCONFDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_UInt16 SSHPort;
} MoxaClassBased_NETCONFDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_NETCONFDataType_Initialize(MoxaClassBased_NETCONFDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_NETCONFDataType_Clear(MoxaClassBased_NETCONFDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_NETCONFDataType_GetSize(MoxaClassBased_NETCONFDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_NETCONFDataType_Encode(MoxaClassBased_NETCONFDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_NETCONFDataType_Decode(MoxaClassBased_NETCONFDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_NETCONFDataType_Compare(const MoxaClassBased_NETCONFDataType* pValue1, const MoxaClassBased_NETCONFDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_NETCONFDataType_Copy(const MoxaClassBased_NETCONFDataType* pSource, MoxaClassBased_NETCONFDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_NETCONFDataType_CopyTo(const MoxaClassBased_NETCONFDataType* pSource, MoxaClassBased_NETCONFDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_NETCONFDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_NETCONFDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_PerStreamPriorityDataType
/*============================================================================
 * The MoxaClassBased_PerStreamPriorityDataType structure.
 *===========================================================================*/
enum MoxaClassBased_PerStreamPriorityDataType_OptionalFields
{
    MoxaClassBased_PerStreamPriorityDataType_OptionalFields_EtherType = 1,
    MoxaClassBased_PerStreamPriorityDataType_OptionalFields_SubtypeEnable = 2,
    MoxaClassBased_PerStreamPriorityDataType_OptionalFields_Subtype = 4,
    MoxaClassBased_PerStreamPriorityDataType_OptionalFields_TCPPort = 8,
    MoxaClassBased_PerStreamPriorityDataType_OptionalFields_UDPPort = 16,
    MoxaClassBased_PerStreamPriorityDataType_OptionalFields_VlanTag = 32
};

typedef struct _MoxaClassBased_PerStreamPriorityDataType
{
    OpcUa_UInt32 EncodingMask;
    MoxaClassBased::PerStreamPriorityModeEnumType PerStreamPriorityMode;
    OpcUa_UInt32 EtherType;
    OpcUa_Boolean SubtypeEnable;
    OpcUa_UInt16 Subtype;
    OpcUa_UInt32 TCPPort;
    OpcUa_UInt32 UDPPort;
    MoxaClassBased_IeeeTsnVlanTagDataType VlanTag;
} MoxaClassBased_PerStreamPriorityDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_PerStreamPriorityDataType_Initialize(MoxaClassBased_PerStreamPriorityDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_PerStreamPriorityDataType_Clear(MoxaClassBased_PerStreamPriorityDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_PerStreamPriorityDataType_GetSize(MoxaClassBased_PerStreamPriorityDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_PerStreamPriorityDataType_Encode(MoxaClassBased_PerStreamPriorityDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_PerStreamPriorityDataType_Decode(MoxaClassBased_PerStreamPriorityDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_PerStreamPriorityDataType_Compare(const MoxaClassBased_PerStreamPriorityDataType* pValue1, const MoxaClassBased_PerStreamPriorityDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_PerStreamPriorityDataType_Copy(const MoxaClassBased_PerStreamPriorityDataType* pSource, MoxaClassBased_PerStreamPriorityDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_PerStreamPriorityDataType_CopyTo(const MoxaClassBased_PerStreamPriorityDataType* pSource, MoxaClassBased_PerStreamPriorityDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_PerStreamPriorityDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_PerStreamPriorityDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_RESTfulDataType
/*============================================================================
 * The MoxaClassBased_RESTfulDataType structure.
 *===========================================================================*/
enum MoxaClassBased_RESTfulDataType_OptionalFields
{
    MoxaClassBased_RESTfulDataType_OptionalFields_Port = 1
};

typedef struct _MoxaClassBased_RESTfulDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_UInt16 Port;
} MoxaClassBased_RESTfulDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_RESTfulDataType_Initialize(MoxaClassBased_RESTfulDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_RESTfulDataType_Clear(MoxaClassBased_RESTfulDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_RESTfulDataType_GetSize(MoxaClassBased_RESTfulDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_RESTfulDataType_Encode(MoxaClassBased_RESTfulDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_RESTfulDataType_Decode(MoxaClassBased_RESTfulDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_RESTfulDataType_Compare(const MoxaClassBased_RESTfulDataType* pValue1, const MoxaClassBased_RESTfulDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_RESTfulDataType_Copy(const MoxaClassBased_RESTfulDataType* pSource, MoxaClassBased_RESTfulDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_RESTfulDataType_CopyTo(const MoxaClassBased_RESTfulDataType* pSource, MoxaClassBased_RESTfulDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_RESTfulDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_RESTfulDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_SNMPDataType
/*============================================================================
 * The MoxaClassBased_SNMPDataType structure.
 *===========================================================================*/
enum MoxaClassBased_SNMPDataType_OptionalFields
{
    MoxaClassBased_SNMPDataType_OptionalFields_ReadCommunity = 1,
    MoxaClassBased_SNMPDataType_OptionalFields_WriteCommunity = 2,
    MoxaClassBased_SNMPDataType_OptionalFields_Port = 4,
    MoxaClassBased_SNMPDataType_OptionalFields_Version = 8
};

typedef struct _MoxaClassBased_SNMPDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String ReadCommunity;
    OpcUa_String WriteCommunity;
    OpcUa_UInt16 Port;
    MoxaClassBased::SNMPVersion Version;
} MoxaClassBased_SNMPDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SNMPDataType_Initialize(MoxaClassBased_SNMPDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SNMPDataType_Clear(MoxaClassBased_SNMPDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPDataType_GetSize(MoxaClassBased_SNMPDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPDataType_Encode(MoxaClassBased_SNMPDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPDataType_Decode(MoxaClassBased_SNMPDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_SNMPDataType_Compare(const MoxaClassBased_SNMPDataType* pValue1, const MoxaClassBased_SNMPDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPDataType_Copy(const MoxaClassBased_SNMPDataType* pSource, MoxaClassBased_SNMPDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPDataType_CopyTo(const MoxaClassBased_SNMPDataType* pSource, MoxaClassBased_SNMPDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_SNMPDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_SNMPDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_SpanningTreeDataType
/*============================================================================
 * The MoxaClassBased_SpanningTreeDataType structure.
 *===========================================================================*/
enum MoxaClassBased_SpanningTreeDataType_OptionalFields
{
    MoxaClassBased_SpanningTreeDataType_OptionalFields_Active = 1,
    MoxaClassBased_SpanningTreeDataType_OptionalFields_Compatibility = 2,
    MoxaClassBased_SpanningTreeDataType_OptionalFields_BridgePriority = 4,
    MoxaClassBased_SpanningTreeDataType_OptionalFields_ForwardDelayTime = 8,
    MoxaClassBased_SpanningTreeDataType_OptionalFields_HelloTime = 16,
    MoxaClassBased_SpanningTreeDataType_OptionalFields_MaxAge = 32
};

typedef struct _MoxaClassBased_SpanningTreeDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_Boolean Active;
    MoxaClassBased::SpanningTreeCompatibilityEnumType Compatibility;
    OpcUa_UInt16 BridgePriority;
    OpcUa_UInt16 ForwardDelayTime;
    OpcUa_UInt16 HelloTime;
    OpcUa_UInt16 MaxAge;
} MoxaClassBased_SpanningTreeDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SpanningTreeDataType_Initialize(MoxaClassBased_SpanningTreeDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SpanningTreeDataType_Clear(MoxaClassBased_SpanningTreeDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreeDataType_GetSize(MoxaClassBased_SpanningTreeDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreeDataType_Encode(MoxaClassBased_SpanningTreeDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreeDataType_Decode(MoxaClassBased_SpanningTreeDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_SpanningTreeDataType_Compare(const MoxaClassBased_SpanningTreeDataType* pValue1, const MoxaClassBased_SpanningTreeDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreeDataType_Copy(const MoxaClassBased_SpanningTreeDataType* pSource, MoxaClassBased_SpanningTreeDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreeDataType_CopyTo(const MoxaClassBased_SpanningTreeDataType* pSource, MoxaClassBased_SpanningTreeDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_SpanningTreeDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_SpanningTreeDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_SpanningTreePortDataType
/*============================================================================
 * The MoxaClassBased_SpanningTreePortDataType structure.
 *===========================================================================*/
enum MoxaClassBased_SpanningTreePortDataType_OptionalFields
{
    MoxaClassBased_SpanningTreePortDataType_OptionalFields_Edge = 1,
    MoxaClassBased_SpanningTreePortDataType_OptionalFields_Priority = 2,
    MoxaClassBased_SpanningTreePortDataType_OptionalFields_PathCost = 4,
    MoxaClassBased_SpanningTreePortDataType_OptionalFields_LinkType = 8,
    MoxaClassBased_SpanningTreePortDataType_OptionalFields_BPDUFilter = 16
};

typedef struct _MoxaClassBased_SpanningTreePortDataType
{
    OpcUa_UInt32 EncodingMask;
    MoxaClassBased::EdgeEnumType Edge;
    OpcUa_Int32 Priority;
    OpcUa_Int32 PathCost;
    MoxaClassBased::LinkTypeEnumType LinkType;
    OpcUa_Boolean BPDUFilter;
} MoxaClassBased_SpanningTreePortDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SpanningTreePortDataType_Initialize(MoxaClassBased_SpanningTreePortDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SpanningTreePortDataType_Clear(MoxaClassBased_SpanningTreePortDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreePortDataType_GetSize(MoxaClassBased_SpanningTreePortDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreePortDataType_Encode(MoxaClassBased_SpanningTreePortDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreePortDataType_Decode(MoxaClassBased_SpanningTreePortDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_SpanningTreePortDataType_Compare(const MoxaClassBased_SpanningTreePortDataType* pValue1, const MoxaClassBased_SpanningTreePortDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreePortDataType_Copy(const MoxaClassBased_SpanningTreePortDataType* pSource, MoxaClassBased_SpanningTreePortDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SpanningTreePortDataType_CopyTo(const MoxaClassBased_SpanningTreePortDataType* pSource, MoxaClassBased_SpanningTreePortDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_SpanningTreePortDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_SpanningTreePortDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_TimeSyncDataType
/*============================================================================
 * The MoxaClassBased_TimeSyncDataType structure.
 *===========================================================================*/
enum MoxaClassBased_TimeSyncDataType_OptionalFields
{
    MoxaClassBased_TimeSyncDataType_OptionalFields_Active = 1
};

typedef struct _MoxaClassBased_TimeSyncDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_Boolean Active;
    MoxaClassBased_IeeeDot1AS2011DataType IeeeDot1AS2011;
} MoxaClassBased_TimeSyncDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TimeSyncDataType_Initialize(MoxaClassBased_TimeSyncDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TimeSyncDataType_Clear(MoxaClassBased_TimeSyncDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TimeSyncDataType_GetSize(MoxaClassBased_TimeSyncDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TimeSyncDataType_Encode(MoxaClassBased_TimeSyncDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TimeSyncDataType_Decode(MoxaClassBased_TimeSyncDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_TimeSyncDataType_Compare(const MoxaClassBased_TimeSyncDataType* pValue1, const MoxaClassBased_TimeSyncDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TimeSyncDataType_Copy(const MoxaClassBased_TimeSyncDataType* pSource, MoxaClassBased_TimeSyncDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TimeSyncDataType_CopyTo(const MoxaClassBased_TimeSyncDataType* pSource, MoxaClassBased_TimeSyncDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_TimeSyncDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_TimeSyncDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_TsnInterfaceConfigurationListenerDataType
/*============================================================================
 * The MoxaClassBased_TsnInterfaceConfigurationListenerDataType structure.
 *===========================================================================*/
typedef struct _MoxaClassBased_TsnInterfaceConfigurationListenerDataType
{
    OpcUa_String IpAddress;
    OpcUa_String InterfaceName;
} MoxaClassBased_TsnInterfaceConfigurationListenerDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnInterfaceConfigurationListenerDataType_Initialize(MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnInterfaceConfigurationListenerDataType_Clear(MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationListenerDataType_GetSize(MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationListenerDataType_Encode(MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationListenerDataType_Decode(MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_TsnInterfaceConfigurationListenerDataType_Compare(const MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pValue1, const MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationListenerDataType_Copy(const MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pSource, MoxaClassBased_TsnInterfaceConfigurationListenerDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationListenerDataType_CopyTo(const MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pSource, MoxaClassBased_TsnInterfaceConfigurationListenerDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_TsnInterfaceConfigurationListenerDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_TsnInterfaceConfigurationListenerDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_TsnInterfaceConfigurationTalkerDataType
/*============================================================================
 * The MoxaClassBased_TsnInterfaceConfigurationTalkerDataType structure.
 *===========================================================================*/
typedef struct _MoxaClassBased_TsnInterfaceConfigurationTalkerDataType
{
    OpcUa_String IpAddress;
    OpcUa_String InterfaceName;
} MoxaClassBased_TsnInterfaceConfigurationTalkerDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnInterfaceConfigurationTalkerDataType_Initialize(MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnInterfaceConfigurationTalkerDataType_Clear(MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationTalkerDataType_GetSize(MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationTalkerDataType_Encode(MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationTalkerDataType_Decode(MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_TsnInterfaceConfigurationTalkerDataType_Compare(const MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pValue1, const MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationTalkerDataType_Copy(const MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pSource, MoxaClassBased_TsnInterfaceConfigurationTalkerDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnInterfaceConfigurationTalkerDataType_CopyTo(const MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pSource, MoxaClassBased_TsnInterfaceConfigurationTalkerDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_TsnInterfaceConfigurationTalkerDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_TsnInterfaceConfigurationTalkerDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_UnicastStaticForwardDataType
/*============================================================================
 * The MoxaClassBased_UnicastStaticForwardDataType structure.
 *===========================================================================*/
enum MoxaClassBased_UnicastStaticForwardDataType_OptionalFields
{
    MoxaClassBased_UnicastStaticForwardDataType_OptionalFields_EgressPort = 1
};

typedef struct _MoxaClassBased_UnicastStaticForwardDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_UInt16 VlanId;
    OpcUa_String MacAddress;
    OpcUa_UInt16 EgressPort;
} MoxaClassBased_UnicastStaticForwardDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_UnicastStaticForwardDataType_Initialize(MoxaClassBased_UnicastStaticForwardDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_UnicastStaticForwardDataType_Clear(MoxaClassBased_UnicastStaticForwardDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_UnicastStaticForwardDataType_GetSize(MoxaClassBased_UnicastStaticForwardDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_UnicastStaticForwardDataType_Encode(MoxaClassBased_UnicastStaticForwardDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_UnicastStaticForwardDataType_Decode(MoxaClassBased_UnicastStaticForwardDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_UnicastStaticForwardDataType_Compare(const MoxaClassBased_UnicastStaticForwardDataType* pValue1, const MoxaClassBased_UnicastStaticForwardDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_UnicastStaticForwardDataType_Copy(const MoxaClassBased_UnicastStaticForwardDataType* pSource, MoxaClassBased_UnicastStaticForwardDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_UnicastStaticForwardDataType_CopyTo(const MoxaClassBased_UnicastStaticForwardDataType* pSource, MoxaClassBased_UnicastStaticForwardDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_UnicastStaticForwardDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_UnicastStaticForwardDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_EthernetInterfaceDataType
/*============================================================================
 * The MoxaClassBased_EthernetInterfaceDataType structure.
 *===========================================================================*/
enum MoxaClassBased_EthernetInterfaceDataType_OptionalFields
{
    MoxaClassBased_EthernetInterfaceDataType_OptionalFields_PhysAddress = 1
};

typedef struct _MoxaClassBased_EthernetInterfaceDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String PhysAddress;
    OpcUa_String InterfaceName;
} MoxaClassBased_EthernetInterfaceDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_EthernetInterfaceDataType_Initialize(MoxaClassBased_EthernetInterfaceDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_EthernetInterfaceDataType_Clear(MoxaClassBased_EthernetInterfaceDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EthernetInterfaceDataType_GetSize(MoxaClassBased_EthernetInterfaceDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EthernetInterfaceDataType_Encode(MoxaClassBased_EthernetInterfaceDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EthernetInterfaceDataType_Decode(MoxaClassBased_EthernetInterfaceDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_EthernetInterfaceDataType_Compare(const MoxaClassBased_EthernetInterfaceDataType* pValue1, const MoxaClassBased_EthernetInterfaceDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EthernetInterfaceDataType_Copy(const MoxaClassBased_EthernetInterfaceDataType* pSource, MoxaClassBased_EthernetInterfaceDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EthernetInterfaceDataType_CopyTo(const MoxaClassBased_EthernetInterfaceDataType* pSource, MoxaClassBased_EthernetInterfaceDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_EthernetInterfaceDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_EthernetInterfaceDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_MulticastStaticForwardDataType
/*============================================================================
 * The MoxaClassBased_MulticastStaticForwardDataType structure.
 *===========================================================================*/
enum MoxaClassBased_MulticastStaticForwardDataType_OptionalFields
{
    MoxaClassBased_MulticastStaticForwardDataType_OptionalFields_EgressPorts = 1,
};

typedef struct _MoxaClassBased_MulticastStaticForwardDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_UInt16 VlanId;
    OpcUa_String MacAddress;
    OpcUa_Int32 NoOfEgressPorts;
    OpcUa_UInt16* EgressPorts;
} MoxaClassBased_MulticastStaticForwardDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_MulticastStaticForwardDataType_Initialize(MoxaClassBased_MulticastStaticForwardDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_MulticastStaticForwardDataType_Clear(MoxaClassBased_MulticastStaticForwardDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_MulticastStaticForwardDataType_GetSize(MoxaClassBased_MulticastStaticForwardDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_MulticastStaticForwardDataType_Encode(MoxaClassBased_MulticastStaticForwardDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_MulticastStaticForwardDataType_Decode(MoxaClassBased_MulticastStaticForwardDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_MulticastStaticForwardDataType_Compare(const MoxaClassBased_MulticastStaticForwardDataType* pValue1, const MoxaClassBased_MulticastStaticForwardDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_MulticastStaticForwardDataType_Copy(const MoxaClassBased_MulticastStaticForwardDataType* pSource, MoxaClassBased_MulticastStaticForwardDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_MulticastStaticForwardDataType_CopyTo(const MoxaClassBased_MulticastStaticForwardDataType* pSource, MoxaClassBased_MulticastStaticForwardDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_MulticastStaticForwardDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_MulticastStaticForwardDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_SNMPTrapHostDataType
/*============================================================================
 * The MoxaClassBased_SNMPTrapHostDataType structure.
 *===========================================================================*/
enum MoxaClassBased_SNMPTrapHostDataType_OptionalFields
{
    MoxaClassBased_SNMPTrapHostDataType_OptionalFields_HostIP = 1,
    MoxaClassBased_SNMPTrapHostDataType_OptionalFields_Mode = 2,
    MoxaClassBased_SNMPTrapHostDataType_OptionalFields_TrapCommunity = 4
};

typedef struct _MoxaClassBased_SNMPTrapHostDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String HostIP;
    MoxaClassBased::SNMPTrapModeEnumType Mode;
    OpcUa_String TrapCommunity;
} MoxaClassBased_SNMPTrapHostDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SNMPTrapHostDataType_Initialize(MoxaClassBased_SNMPTrapHostDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SNMPTrapHostDataType_Clear(MoxaClassBased_SNMPTrapHostDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPTrapHostDataType_GetSize(MoxaClassBased_SNMPTrapHostDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPTrapHostDataType_Encode(MoxaClassBased_SNMPTrapHostDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPTrapHostDataType_Decode(MoxaClassBased_SNMPTrapHostDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_SNMPTrapHostDataType_Compare(const MoxaClassBased_SNMPTrapHostDataType* pValue1, const MoxaClassBased_SNMPTrapHostDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPTrapHostDataType_Copy(const MoxaClassBased_SNMPTrapHostDataType* pSource, MoxaClassBased_SNMPTrapHostDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SNMPTrapHostDataType_CopyTo(const MoxaClassBased_SNMPTrapHostDataType* pSource, MoxaClassBased_SNMPTrapHostDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_SNMPTrapHostDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_SNMPTrapHostDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_SyslogServerDataType
/*============================================================================
 * The MoxaClassBased_SyslogServerDataType structure.
 *===========================================================================*/
enum MoxaClassBased_SyslogServerDataType_OptionalFields
{
    MoxaClassBased_SyslogServerDataType_OptionalFields_Enabled = 1,
    MoxaClassBased_SyslogServerDataType_OptionalFields_SyslogServer1 = 2,
    MoxaClassBased_SyslogServerDataType_OptionalFields_Address1 = 4,
    MoxaClassBased_SyslogServerDataType_OptionalFields_Port1 = 8,
    MoxaClassBased_SyslogServerDataType_OptionalFields_SyslogServer2 = 16,
    MoxaClassBased_SyslogServerDataType_OptionalFields_Address2 = 32,
    MoxaClassBased_SyslogServerDataType_OptionalFields_Port2 = 64,
    MoxaClassBased_SyslogServerDataType_OptionalFields_SyslogServer3 = 128,
    MoxaClassBased_SyslogServerDataType_OptionalFields_Address3 = 256,
    MoxaClassBased_SyslogServerDataType_OptionalFields_Port3 = 512
};

typedef struct _MoxaClassBased_SyslogServerDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_Boolean Enabled;
    OpcUa_Boolean SyslogServer1;
    OpcUa_String Address1;
    OpcUa_UInt16 Port1;
    OpcUa_Boolean SyslogServer2;
    OpcUa_String Address2;
    OpcUa_UInt16 Port2;
    OpcUa_Boolean SyslogServer3;
    OpcUa_String Address3;
    OpcUa_UInt16 Port3;
} MoxaClassBased_SyslogServerDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SyslogServerDataType_Initialize(MoxaClassBased_SyslogServerDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_SyslogServerDataType_Clear(MoxaClassBased_SyslogServerDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SyslogServerDataType_GetSize(MoxaClassBased_SyslogServerDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SyslogServerDataType_Encode(MoxaClassBased_SyslogServerDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SyslogServerDataType_Decode(MoxaClassBased_SyslogServerDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_SyslogServerDataType_Compare(const MoxaClassBased_SyslogServerDataType* pValue1, const MoxaClassBased_SyslogServerDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SyslogServerDataType_Copy(const MoxaClassBased_SyslogServerDataType* pSource, MoxaClassBased_SyslogServerDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_SyslogServerDataType_CopyTo(const MoxaClassBased_SyslogServerDataType* pSource, MoxaClassBased_SyslogServerDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_SyslogServerDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_SyslogServerDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_TrafficConfigurationEntryDataType
/*============================================================================
 * The MoxaClassBased_TrafficConfigurationEntryDataType structure.
 *===========================================================================*/
enum MoxaClassBased_TrafficConfigurationEntryDataType_OptionalFields
{
    MoxaClassBased_TrafficConfigurationEntryDataType_OptionalFields_TrafficType = 1,
    MoxaClassBased_TrafficConfigurationEntryDataType_OptionalFields_PCP = 2,
    MoxaClassBased_TrafficConfigurationEntryDataType_OptionalFields_ReservedTime = 4,
};

typedef struct _MoxaClassBased_TrafficConfigurationEntryDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_Byte Index;
    OpcUa_String TrafficType;
    OpcUa_Int32 NoOfPCP;
    OpcUa_Byte* PCP;
    OpcUa_Double ReservedTime;
} MoxaClassBased_TrafficConfigurationEntryDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TrafficConfigurationEntryDataType_Initialize(MoxaClassBased_TrafficConfigurationEntryDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TrafficConfigurationEntryDataType_Clear(MoxaClassBased_TrafficConfigurationEntryDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TrafficConfigurationEntryDataType_GetSize(MoxaClassBased_TrafficConfigurationEntryDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TrafficConfigurationEntryDataType_Encode(MoxaClassBased_TrafficConfigurationEntryDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TrafficConfigurationEntryDataType_Decode(MoxaClassBased_TrafficConfigurationEntryDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_TrafficConfigurationEntryDataType_Compare(const MoxaClassBased_TrafficConfigurationEntryDataType* pValue1, const MoxaClassBased_TrafficConfigurationEntryDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TrafficConfigurationEntryDataType_Copy(const MoxaClassBased_TrafficConfigurationEntryDataType* pSource, MoxaClassBased_TrafficConfigurationEntryDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TrafficConfigurationEntryDataType_CopyTo(const MoxaClassBased_TrafficConfigurationEntryDataType* pSource, MoxaClassBased_TrafficConfigurationEntryDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_TrafficConfigurationEntryDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_TrafficConfigurationEntryDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_TsnStreamApplicationDataType
/*============================================================================
 * The MoxaClassBased_TsnStreamApplicationDataType structure.
 *===========================================================================*/
enum MoxaClassBased_TsnStreamApplicationDataType_OptionalFields
{
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_ApplicationName = 1,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_FRERMode = 2,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_TrafficType = 4,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_QoSType = 8,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_ReceiveOffsetMin = 16,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_ReceiveOffsetMax = 32,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_LatencyMax = 64,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_TagStream = 128,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_TagStreamVlanTag = 256,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_TagMethod = 512,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_PerStreamPriority = 1024,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_TsnTrafficSpecification = 2048,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_TransmissionOffsetMin = 4096,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_TransmissionOffsetMax = 8192,
    MoxaClassBased_TsnStreamApplicationDataType_OptionalFields_TransmissionJitter = 16384
};

typedef struct _MoxaClassBased_TsnStreamApplicationDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String ApplicationName;
    OpcUa_Boolean FRERMode;
    OpcUa_String TrafficType;
    MoxaClassBased::QoSEnumType QoSType;
    OpcUa_Double ReceiveOffsetMin;
    OpcUa_Double ReceiveOffsetMax;
    OpcUa_Double LatencyMax;
    OpcUa_Boolean TagStream;
    MoxaClassBased_IeeeTsnVlanTagDataType TagStreamVlanTag;
    MoxaClassBased::TagMethodEnumType TagMethod;
    MoxaClassBased_PerStreamPriorityDataType PerStreamPriority;
    MoxaClassBased_TsnTrafficSpecificationDataType TsnTrafficSpecification;
    OpcUa_Double TransmissionOffsetMin;
    OpcUa_Double TransmissionOffsetMax;
    OpcUa_Double TransmissionJitter;
} MoxaClassBased_TsnStreamApplicationDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnStreamApplicationDataType_Initialize(MoxaClassBased_TsnStreamApplicationDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnStreamApplicationDataType_Clear(MoxaClassBased_TsnStreamApplicationDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamApplicationDataType_GetSize(MoxaClassBased_TsnStreamApplicationDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamApplicationDataType_Encode(MoxaClassBased_TsnStreamApplicationDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamApplicationDataType_Decode(MoxaClassBased_TsnStreamApplicationDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_TsnStreamApplicationDataType_Compare(const MoxaClassBased_TsnStreamApplicationDataType* pValue1, const MoxaClassBased_TsnStreamApplicationDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamApplicationDataType_Copy(const MoxaClassBased_TsnStreamApplicationDataType* pSource, MoxaClassBased_TsnStreamApplicationDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamApplicationDataType_CopyTo(const MoxaClassBased_TsnStreamApplicationDataType* pSource, MoxaClassBased_TsnStreamApplicationDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_TsnStreamApplicationDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_TsnStreamApplicationDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_TsnStreamDataType
/*============================================================================
 * The MoxaClassBased_TsnStreamDataType structure.
 *===========================================================================*/
enum MoxaClassBased_TsnStreamDataType_OptionalFields
{
    MoxaClassBased_TsnStreamDataType_OptionalFields_StreamName = 1,
    MoxaClassBased_TsnStreamDataType_OptionalFields_ApplicationName = 2,
    MoxaClassBased_TsnStreamDataType_OptionalFields_Multicast = 4,
    MoxaClassBased_TsnStreamDataType_OptionalFields_DestinationAddress = 8,
    MoxaClassBased_TsnStreamDataType_OptionalFields_TsnTalkerInterfaceConfiguration = 16,
    MoxaClassBased_TsnStreamDataType_OptionalFields_TsnListenerInterfaceConfiguration = 32,
};

typedef struct _MoxaClassBased_TsnStreamDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String StreamName;
    OpcUa_String ApplicationName;
    OpcUa_Boolean Multicast;
    OpcUa_String DestinationAddress;
    MoxaClassBased_TsnInterfaceConfigurationTalkerDataType TsnTalkerInterfaceConfiguration;
    OpcUa_Int32 NoOfTsnListenerInterfaceConfiguration;
    MoxaClassBased_TsnInterfaceConfigurationListenerDataType* TsnListenerInterfaceConfiguration;
} MoxaClassBased_TsnStreamDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnStreamDataType_Initialize(MoxaClassBased_TsnStreamDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_TsnStreamDataType_Clear(MoxaClassBased_TsnStreamDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamDataType_GetSize(MoxaClassBased_TsnStreamDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamDataType_Encode(MoxaClassBased_TsnStreamDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamDataType_Decode(MoxaClassBased_TsnStreamDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_TsnStreamDataType_Compare(const MoxaClassBased_TsnStreamDataType* pValue1, const MoxaClassBased_TsnStreamDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamDataType_Copy(const MoxaClassBased_TsnStreamDataType* pSource, MoxaClassBased_TsnStreamDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_TsnStreamDataType_CopyTo(const MoxaClassBased_TsnStreamDataType* pSource, MoxaClassBased_TsnStreamDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_TsnStreamDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_TsnStreamDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_VlanDataType
/*============================================================================
 * The MoxaClassBased_VlanDataType structure.
 *===========================================================================*/
enum MoxaClassBased_VlanDataType_OptionalFields
{
    MoxaClassBased_VlanDataType_OptionalFields_VlanName = 1,
    MoxaClassBased_VlanDataType_OptionalFields_TeMstid = 2,
    MoxaClassBased_VlanDataType_OptionalFields_MemberPort = 4,
};

typedef struct _MoxaClassBased_VlanDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_UInt16 VlanId;
    OpcUa_String VlanName;
    OpcUa_Boolean TeMstid;
    OpcUa_Int32 NoOfMemberPort;
    OpcUa_UInt16* MemberPort;
} MoxaClassBased_VlanDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_VlanDataType_Initialize(MoxaClassBased_VlanDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_VlanDataType_Clear(MoxaClassBased_VlanDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanDataType_GetSize(MoxaClassBased_VlanDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanDataType_Encode(MoxaClassBased_VlanDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanDataType_Decode(MoxaClassBased_VlanDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_VlanDataType_Compare(const MoxaClassBased_VlanDataType* pValue1, const MoxaClassBased_VlanDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanDataType_Copy(const MoxaClassBased_VlanDataType* pSource, MoxaClassBased_VlanDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanDataType_CopyTo(const MoxaClassBased_VlanDataType* pSource, MoxaClassBased_VlanDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_VlanDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_VlanDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_VlanPortDataType
/*============================================================================
 * The MoxaClassBased_VlanPortDataType structure.
 *===========================================================================*/
enum MoxaClassBased_VlanPortDataType_OptionalFields
{
    MoxaClassBased_VlanPortDataType_OptionalFields_Mode = 1,
    MoxaClassBased_VlanPortDataType_OptionalFields_Pvid = 2,
    MoxaClassBased_VlanPortDataType_OptionalFields_PriorityCodePoint = 4,
    MoxaClassBased_VlanPortDataType_OptionalFields_UntaggedVlan = 8,
    MoxaClassBased_VlanPortDataType_OptionalFields_TaggedVlan = 16,
};

typedef struct _MoxaClassBased_VlanPortDataType
{
    OpcUa_UInt32 EncodingMask;
    MoxaClassBased::PortModeEnumType Mode;
    OpcUa_UInt16 Pvid;
    OpcUa_UInt16 PriorityCodePoint;
    OpcUa_Int32 NoOfUntaggedVlan;
    OpcUa_UInt16* UntaggedVlan;
    OpcUa_Int32 NoOfTaggedVlan;
    OpcUa_UInt16* TaggedVlan;
} MoxaClassBased_VlanPortDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_VlanPortDataType_Initialize(MoxaClassBased_VlanPortDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_VlanPortDataType_Clear(MoxaClassBased_VlanPortDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanPortDataType_GetSize(MoxaClassBased_VlanPortDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanPortDataType_Encode(MoxaClassBased_VlanPortDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanPortDataType_Decode(MoxaClassBased_VlanPortDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_VlanPortDataType_Compare(const MoxaClassBased_VlanPortDataType* pValue1, const MoxaClassBased_VlanPortDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanPortDataType_Copy(const MoxaClassBased_VlanPortDataType* pSource, MoxaClassBased_VlanPortDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanPortDataType_CopyTo(const MoxaClassBased_VlanPortDataType* pSource, MoxaClassBased_VlanPortDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_VlanPortDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_VlanPortDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_VlanSettingDataType
/*============================================================================
 * The MoxaClassBased_VlanSettingDataType structure.
 *===========================================================================*/
enum MoxaClassBased_VlanSettingDataType_OptionalFields
{
    MoxaClassBased_VlanSettingDataType_OptionalFields_ManagementVlan = 1
};

typedef struct _MoxaClassBased_VlanSettingDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_UInt16 ManagementVlan;
} MoxaClassBased_VlanSettingDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_VlanSettingDataType_Initialize(MoxaClassBased_VlanSettingDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_VlanSettingDataType_Clear(MoxaClassBased_VlanSettingDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanSettingDataType_GetSize(MoxaClassBased_VlanSettingDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanSettingDataType_Encode(MoxaClassBased_VlanSettingDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanSettingDataType_Decode(MoxaClassBased_VlanSettingDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_VlanSettingDataType_Compare(const MoxaClassBased_VlanSettingDataType* pValue1, const MoxaClassBased_VlanSettingDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanSettingDataType_Copy(const MoxaClassBased_VlanSettingDataType* pSource, MoxaClassBased_VlanSettingDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_VlanSettingDataType_CopyTo(const MoxaClassBased_VlanSettingDataType* pSource, MoxaClassBased_VlanSettingDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_VlanSettingDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_VlanSettingDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_AutoScanDataType
/*============================================================================
 * The MoxaClassBased_AutoScanDataType structure.
 *===========================================================================*/
enum MoxaClassBased_AutoScanDataType_OptionalFields
{
    MoxaClassBased_AutoScanDataType_OptionalFields_NETCONF = 1,
    MoxaClassBased_AutoScanDataType_OptionalFields_SNMP = 2,
    MoxaClassBased_AutoScanDataType_OptionalFields_RESTful = 4
};

typedef struct _MoxaClassBased_AutoScanDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String FirstIpAddress;
    OpcUa_String LastIpAddress;
    MoxaClassBased_NETCONFDataType NETCONF;
    MoxaClassBased_SNMPDataType SNMP;
    MoxaClassBased_RESTfulDataType RESTful;
} MoxaClassBased_AutoScanDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_AutoScanDataType_Initialize(MoxaClassBased_AutoScanDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_AutoScanDataType_Clear(MoxaClassBased_AutoScanDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_AutoScanDataType_GetSize(MoxaClassBased_AutoScanDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_AutoScanDataType_Encode(MoxaClassBased_AutoScanDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_AutoScanDataType_Decode(MoxaClassBased_AutoScanDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_AutoScanDataType_Compare(const MoxaClassBased_AutoScanDataType* pValue1, const MoxaClassBased_AutoScanDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_AutoScanDataType_Copy(const MoxaClassBased_AutoScanDataType* pSource, MoxaClassBased_AutoScanDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_AutoScanDataType_CopyTo(const MoxaClassBased_AutoScanDataType* pSource, MoxaClassBased_AutoScanDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_AutoScanDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_AutoScanDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_BridgeDataType
/*============================================================================
 * The MoxaClassBased_BridgeDataType structure.
 *===========================================================================*/
enum MoxaClassBased_BridgeDataType_OptionalFields
{
    MoxaClassBased_BridgeDataType_OptionalFields_Alias = 1,
    MoxaClassBased_BridgeDataType_OptionalFields_DeviceProfileName = 2,
    MoxaClassBased_BridgeDataType_OptionalFields_FirmwareVersion = 4
};

typedef struct _MoxaClassBased_BridgeDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String Alias;
    OpcUa_String DeviceProfileName;
    OpcUa_String FirmwareVersion;
    MoxaClassBased_ConnectionAccountDataType ConnectionAccount;
    MoxaClassBased_NETCONFDataType NETCONF;
    MoxaClassBased_SNMPDataType SNMP;
    MoxaClassBased_RESTfulDataType RESTful;
    MoxaClassBased_IpSettingDataType IpSetting;
} MoxaClassBased_BridgeDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_BridgeDataType_Initialize(MoxaClassBased_BridgeDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_BridgeDataType_Clear(MoxaClassBased_BridgeDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_BridgeDataType_GetSize(MoxaClassBased_BridgeDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_BridgeDataType_Encode(MoxaClassBased_BridgeDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_BridgeDataType_Decode(MoxaClassBased_BridgeDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_BridgeDataType_Compare(const MoxaClassBased_BridgeDataType* pValue1, const MoxaClassBased_BridgeDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_BridgeDataType_Copy(const MoxaClassBased_BridgeDataType* pSource, MoxaClassBased_BridgeDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_BridgeDataType_CopyTo(const MoxaClassBased_BridgeDataType* pSource, MoxaClassBased_BridgeDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_BridgeDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_BridgeDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_EndStationDataType
/*============================================================================
 * The MoxaClassBased_EndStationDataType structure.
 *===========================================================================*/
enum MoxaClassBased_EndStationDataType_OptionalFields
{
    MoxaClassBased_EndStationDataType_OptionalFields_Alias = 1,
    MoxaClassBased_EndStationDataType_OptionalFields_DeviceProfileName = 2,
    MoxaClassBased_EndStationDataType_OptionalFields_FirmwareVersion = 4,
    MoxaClassBased_EndStationDataType_OptionalFields_MacAddress = 8
};

typedef struct _MoxaClassBased_EndStationDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String Alias;
    OpcUa_String DeviceProfileName;
    OpcUa_String FirmwareVersion;
    MoxaClassBased_ConnectionAccountDataType ConnectionAccount;
    MoxaClassBased_NETCONFDataType NETCONF;
    MoxaClassBased_SNMPDataType SNMP;
    MoxaClassBased_RESTfulDataType RESTful;
    MoxaClassBased_IpSettingDataType IpSetting;
    OpcUa_String MacAddress;
    OpcUa_Int32 NoOfEthernetInterfaces;
    MoxaClassBased_EthernetInterfaceDataType* EthernetInterfaces;
} MoxaClassBased_EndStationDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_EndStationDataType_Initialize(MoxaClassBased_EndStationDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_EndStationDataType_Clear(MoxaClassBased_EndStationDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EndStationDataType_GetSize(MoxaClassBased_EndStationDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EndStationDataType_Encode(MoxaClassBased_EndStationDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EndStationDataType_Decode(MoxaClassBased_EndStationDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_EndStationDataType_Compare(const MoxaClassBased_EndStationDataType* pValue1, const MoxaClassBased_EndStationDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EndStationDataType_Copy(const MoxaClassBased_EndStationDataType* pSource, MoxaClassBased_EndStationDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_EndStationDataType_CopyTo(const MoxaClassBased_EndStationDataType* pSource, MoxaClassBased_EndStationDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_EndStationDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_EndStationDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_DeviceDiscoveryDataType
/*============================================================================
 * The MoxaClassBased_DeviceDiscoveryDataType structure.
 *===========================================================================*/
enum MoxaClassBased_DeviceDiscoveryDataType_OptionalFields
{
    MoxaClassBased_DeviceDiscoveryDataType_OptionalFields_SNMP = 1,
    MoxaClassBased_DeviceDiscoveryDataType_OptionalFields_RESTful = 2
};

typedef struct _MoxaClassBased_DeviceDiscoveryDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_Boolean MoxaIndustrialEthernetSwitch;
    MoxaClassBased_SNMPDataType SNMP;
    MoxaClassBased_RESTfulDataType RESTful;
} MoxaClassBased_DeviceDiscoveryDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_DeviceDiscoveryDataType_Initialize(MoxaClassBased_DeviceDiscoveryDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_DeviceDiscoveryDataType_Clear(MoxaClassBased_DeviceDiscoveryDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceDiscoveryDataType_GetSize(MoxaClassBased_DeviceDiscoveryDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceDiscoveryDataType_Encode(MoxaClassBased_DeviceDiscoveryDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceDiscoveryDataType_Decode(MoxaClassBased_DeviceDiscoveryDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_DeviceDiscoveryDataType_Compare(const MoxaClassBased_DeviceDiscoveryDataType* pValue1, const MoxaClassBased_DeviceDiscoveryDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceDiscoveryDataType_Copy(const MoxaClassBased_DeviceDiscoveryDataType* pSource, MoxaClassBased_DeviceDiscoveryDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_DeviceDiscoveryDataType_CopyTo(const MoxaClassBased_DeviceDiscoveryDataType* pSource, MoxaClassBased_DeviceDiscoveryDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_DeviceDiscoveryDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_DeviceDiscoveryDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_ProjectSettingDataType
/*============================================================================
 * The MoxaClassBased_ProjectSettingDataType structure.
 *===========================================================================*/
enum MoxaClassBased_ProjectSettingDataType_OptionalFields
{
    MoxaClassBased_ProjectSettingDataType_OptionalFields_ProjectName = 1
};

typedef struct _MoxaClassBased_ProjectSettingDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String ProjectName;
    MoxaClassBased_ConnectionAccountDataType ConnectionAccount;
    MoxaClassBased_IpSettingDataType BaseIpSetting;
    MoxaClassBased_NETCONFDataType NETCONF;
    MoxaClassBased_SNMPDataType SNMP;
    MoxaClassBased_RESTfulDataType RESTful;
} MoxaClassBased_ProjectSettingDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_ProjectSettingDataType_Initialize(MoxaClassBased_ProjectSettingDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_ProjectSettingDataType_Clear(MoxaClassBased_ProjectSettingDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ProjectSettingDataType_GetSize(MoxaClassBased_ProjectSettingDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ProjectSettingDataType_Encode(MoxaClassBased_ProjectSettingDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ProjectSettingDataType_Decode(MoxaClassBased_ProjectSettingDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_ProjectSettingDataType_Compare(const MoxaClassBased_ProjectSettingDataType* pValue1, const MoxaClassBased_ProjectSettingDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ProjectSettingDataType_Copy(const MoxaClassBased_ProjectSettingDataType* pSource, MoxaClassBased_ProjectSettingDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_ProjectSettingDataType_CopyTo(const MoxaClassBased_ProjectSettingDataType* pSource, MoxaClassBased_ProjectSettingDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_ProjectSettingDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_ProjectSettingDataType*/

#ifndef OPCUA_EXCLUDE_MoxaClassBased_StreamComputedResultDataType
/*============================================================================
 * The MoxaClassBased_StreamComputedResultDataType structure.
 *===========================================================================*/
typedef struct _MoxaClassBased_StreamComputedResultDataType
{
    OpcUa_String StreamName;
    OpcUa_String TrafficType;
    MoxaClassBased_IeeeTsnVlanTagDataType VlanTag;
    MoxaClassBased_TsnInterfaceConfigurationTalkerDataType Talker;
    OpcUa_Int32 NoOfListeners;
    MoxaClassBased_TsnInterfaceConfigurationListenerDataType* Listeners;
} MoxaClassBased_StreamComputedResultDataType;

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_StreamComputedResultDataType_Initialize(MoxaClassBased_StreamComputedResultDataType* pValue);

MoxaClassBased_EXPORT OpcUa_Void MoxaClassBased_StreamComputedResultDataType_Clear(MoxaClassBased_StreamComputedResultDataType* pValue);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_StreamComputedResultDataType_GetSize(MoxaClassBased_StreamComputedResultDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_StreamComputedResultDataType_Encode(MoxaClassBased_StreamComputedResultDataType* pValue, struct _OpcUa_Encoder* pEncoder);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_StreamComputedResultDataType_Decode(MoxaClassBased_StreamComputedResultDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
MoxaClassBased_EXPORT OpcUa_Int        MoxaClassBased_StreamComputedResultDataType_Compare(const MoxaClassBased_StreamComputedResultDataType* pValue1, const MoxaClassBased_StreamComputedResultDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_StreamComputedResultDataType_Copy(const MoxaClassBased_StreamComputedResultDataType* pSource, MoxaClassBased_StreamComputedResultDataType** ppCopy);

MoxaClassBased_EXPORT OpcUa_StatusCode MoxaClassBased_StreamComputedResultDataType_CopyTo(const MoxaClassBased_StreamComputedResultDataType* pSource, MoxaClassBased_StreamComputedResultDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType MoxaClassBased_StreamComputedResultDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_MoxaClassBased_StreamComputedResultDataType*/


/*============================================================================
 * Table of known types.
 *===========================================================================*/
extern struct _OpcUa_EncodeableType** MoxaClassBased_KnownEncodeableTypes;

/*============================================================================
 * Register known types.
 *===========================================================================*/
namespace MoxaClassBased
{
    /** Class used to handle data type registration
    */
    class DataTypes
    {
    public:
        static void registerStructuredTypes();
    private:
        static bool s_dataTypesAdded;
    };
}

#endif // __MOXACLASSBASED_DATATYPES_H__

