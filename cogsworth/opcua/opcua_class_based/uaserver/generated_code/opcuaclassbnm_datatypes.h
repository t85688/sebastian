/******************************************************************************
** opcuaclassbnm_datatypes.h
**
**   **************************** auto-generated ****************************
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.8.0, using C++ OPC UA SDK 1.8.2 template (version 4)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
**   **************************** auto-generated ****************************
**
** Copyright (c) 2006-2025 Unified Automation GmbH. All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
** Project: C++ OPC Server SDK information model for namespace http://opcfoundation.org/UA/BNM/
**
** Description: OPC Unified Architecture Software Development Kit.
**
******************************************************************************/

#ifndef __OPCUACLASSBNM_DATATYPES_H__
#define __OPCUACLASSBNM_DATATYPES_H__

#include <opcua_proxystub.h>
#include <opcua_builtintypes.h>
#include <opcua_exclusions.h>
#include <opcua_types.h>

#include "opcuaclassbnm_identifiers.h"

#define OPCUACLASSBNM_EXTENSIONOBJECT_GET_ENCODEABLE(xExpectedType, xExtensionObject) \
    (OpcUaClassBnm_##xExpectedType*)((((xExtensionObject)->Encoding == OpcUa_ExtensionObjectEncoding_EncodeableObject && \
    (xExtensionObject)->Body.EncodeableObject.Type != OpcUa_Null && \
    (xExtensionObject)->Body.EncodeableObject.Type->TypeId == OpcUaClassBnmId_##xExpectedType && \
    OpcUa_StrCmpA((xExtensionObject)->Body.EncodeableObject.Type->NamespaceUri, "http://opcfoundation.org/UA/BNM/") == 0 && \
    (xExtensionObject)->Body.EncodeableObject.Object != OpcUa_Null))?((xExtensionObject)->Body.EncodeableObject.Object):OpcUa_Null)


// Namespace for the UA information model http://opcfoundation.org/UA/BNM/
namespace OpcUaClassBnm {

#ifndef OPCUA_EXCLUDE_Duplex
/*============================================================================
 * The Duplex enumeration.
 *===========================================================================*/
enum Duplex
{
    Duplex_full = 0 /**<Full duplex.*/,
    Duplex_half = 1 /**<Half duplex.*/,
    Duplex_unknown = 2 /**<Link is currently disconnected or initializing.*/
#if OPCUA_FORCE_INT32_ENUMS
    ,_Duplex_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

OpcUaClassBnm_EXPORT inline void Duplex_Clear(Duplex *pValue) {*pValue = Duplex_full;}

OpcUaClassBnm_EXPORT inline void Duplex_Initialize(Duplex *pValue) {*pValue = Duplex_full;}

OpcUaClassBnm_EXPORT extern struct ::_OpcUa_EnumeratedType Duplex_EnumeratedType;

#endif /*OPCUA_EXCLUDE_Duplex*/
#ifndef OPCUA_EXCLUDE_InterfaceAdminStatus
/*============================================================================
 * The InterfaceAdminStatus enumeration.
 *===========================================================================*/
enum InterfaceAdminStatus
{
    InterfaceAdminStatus_up = 0 /**<Ready to pass packets.*/,
    InterfaceAdminStatus_down = 1 /**<Not ready to pass packets and not in some test mode.*/,
    InterfaceAdminStatus_testing = 2 /**<In some test mode.*/
#if OPCUA_FORCE_INT32_ENUMS
    ,_InterfaceAdminStatus_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

OpcUaClassBnm_EXPORT inline void InterfaceAdminStatus_Clear(InterfaceAdminStatus *pValue) {*pValue = InterfaceAdminStatus_up;}

OpcUaClassBnm_EXPORT inline void InterfaceAdminStatus_Initialize(InterfaceAdminStatus *pValue) {*pValue = InterfaceAdminStatus_up;}

OpcUaClassBnm_EXPORT extern struct ::_OpcUa_EnumeratedType InterfaceAdminStatus_EnumeratedType;

#endif /*OPCUA_EXCLUDE_InterfaceAdminStatus*/
#ifndef OPCUA_EXCLUDE_InterfaceOperStatus
/*============================================================================
 * The InterfaceOperStatus enumeration.
 *===========================================================================*/
enum InterfaceOperStatus
{
    InterfaceOperStatus_up = 0 /**<Ready to pass packets.*/,
    InterfaceOperStatus_down = 1 /**<The interface does not pass any packets.*/,
    InterfaceOperStatus_testing = 2 /**<In some test mode. No operational packets can be passed.*/,
    InterfaceOperStatus_unknown = 3 /**<Status cannot be determined for some reason.*/,
    InterfaceOperStatus_dormant = 4 /**<Waiting for some external event.*/,
    InterfaceOperStatus_not_present = 5 /**<Some component (typically hardware) is missing.*/,
    InterfaceOperStatus_lower_layer_down = 6 /**<Down due to state of lower-layer interface(s).*/
#if OPCUA_FORCE_INT32_ENUMS
    ,_InterfaceOperStatus_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

OpcUaClassBnm_EXPORT inline void InterfaceOperStatus_Clear(InterfaceOperStatus *pValue) {*pValue = InterfaceOperStatus_up;}

OpcUaClassBnm_EXPORT inline void InterfaceOperStatus_Initialize(InterfaceOperStatus *pValue) {*pValue = InterfaceOperStatus_up;}

OpcUaClassBnm_EXPORT extern struct ::_OpcUa_EnumeratedType InterfaceOperStatus_EnumeratedType;

#endif /*OPCUA_EXCLUDE_InterfaceOperStatus*/
#ifndef OPCUA_EXCLUDE_NegotiationStatus
/*============================================================================
 * The NegotiationStatus enumeration.
 *===========================================================================*/
enum NegotiationStatus
{
    NegotiationStatus_in_progress = 0 /**<The auto-negotiation protocol is running and negotiation is currently in-progress.*/,
    NegotiationStatus_complete = 1 /**<The auto-negotiation protocol has completed successfully.*/,
    NegotiationStatus_failed = 2 /**<The auto-negotiation protocol has failed.*/,
    NegotiationStatus_unknown = 3 /**<The auto-negotiation status is not currently known, this could be because it is still negotiating or the protocol cannot run (e.g., if no medium is present).*/,
    NegotiationStatus_no_negotiation = 4 /**<No auto-negotiation is executed. The auto-negotiation function is either not supported on this interface or has not been enabled.*/
#if OPCUA_FORCE_INT32_ENUMS
    ,_NegotiationStatus_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

OpcUaClassBnm_EXPORT inline void NegotiationStatus_Clear(NegotiationStatus *pValue) {*pValue = NegotiationStatus_in_progress;}

OpcUaClassBnm_EXPORT inline void NegotiationStatus_Initialize(NegotiationStatus *pValue) {*pValue = NegotiationStatus_in_progress;}

OpcUaClassBnm_EXPORT extern struct ::_OpcUa_EnumeratedType NegotiationStatus_EnumeratedType;

#endif /*OPCUA_EXCLUDE_NegotiationStatus*/
#ifndef OPCUA_EXCLUDE_TsnFailureCode
/*============================================================================
 * The TsnFailureCode enumeration.
 *===========================================================================*/
enum TsnFailureCode
{
    TsnFailureCode_noFailure = 0 /**<No failure*/,
    TsnFailureCode_insufficientBandwidth = 1 /**<Insufficient bandwidth*/,
    TsnFailureCode_insufficientResources = 2 /**<Insufficient bridge resources*/,
    TsnFailureCode_insufficientTrafficClassBandwidth = 3 /**<Insufficient bandwidth for Traffic Class*/,
    TsnFailureCode_streamIDInUse = 4 /**<StreamID in use by another Talker*/,
    TsnFailureCode_streamDestinationAddressInUse = 5 /**<Stream destination address already in use*/,
    TsnFailureCode_streamPreemptedByHigherRank = 6 /**<Stream pre-empted by higher rank*/,
    TsnFailureCode_latencyHasChanged = 7 /**<Reported latency has changed*/,
    TsnFailureCode_egressPortNotAVBCapable = 8 /**<Egress port is not AVBCapable*/,
    TsnFailureCode_useDifferentDestinationAddress = 9 /**<Use a different destination address*/,
    TsnFailureCode_outOfMSRPResources = 10 /**<Out of MSRP resources*/,
    TsnFailureCode_outOfMMRPResources = 11 /**<Out of MMRP resources*/,
    TsnFailureCode_cannotStoreDestinationAddress = 12 /**<Cannot store destination address*/,
    TsnFailureCode_priorityIsNoAnSRCLass = 13 /**<Requested priority is not an SR Class priority*/,
    TsnFailureCode_maxFrameSizeTooLarge = 14 /**<MaxFrameSize is too large for media*/,
    TsnFailureCode_maxFanInPortsLimitReached = 15 /**<maxFanInPorts limit has been reached*/,
    TsnFailureCode_firstValueChangedForStreamID = 16 /**<Changes in FirstValue for a registered StreamID*/,
    TsnFailureCode_vlanBlockedOnEgress = 17 /**<VLAN is blocked on this egress port (Registration Forbidden)*/,
    TsnFailureCode_vlanTaggingDisabledOnEgress = 18 /**<VLAN tagging is disabled on this egress port (untagged set)*/,
    TsnFailureCode_srClassPriorityMismatch = 19 /**<SR class priority mismatch*/,
    TsnFailureCode_featureNotPropagated = 20 /**<Enhanced feature cannot be propagated to original Port*/,
    TsnFailureCode_maxLatencyExceeded = 21 /**<MaxLatency exceeded*/,
    TsnFailureCode_bridgeDoesNotProvideNetworkID = 22 /**<Nearest Bridge cannot provide network identification for stream transformation*/,
    TsnFailureCode_streamTransformNotSupported = 23 /**<Stream transformation not supported*/,
    TsnFailureCode_streamIDTypeNotSupported = 24 /**<Stream identification type not supported for stream transformation*/,
    TsnFailureCode_featureNotSupported = 25 /**<Enhanced feature cannot be supported without a CNC*/
#if OPCUA_FORCE_INT32_ENUMS
    ,_TsnFailureCode_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

OpcUaClassBnm_EXPORT inline void TsnFailureCode_Clear(TsnFailureCode *pValue) {*pValue = TsnFailureCode_noFailure;}

OpcUaClassBnm_EXPORT inline void TsnFailureCode_Initialize(TsnFailureCode *pValue) {*pValue = TsnFailureCode_noFailure;}

OpcUaClassBnm_EXPORT extern struct ::_OpcUa_EnumeratedType TsnFailureCode_EnumeratedType;

#endif /*OPCUA_EXCLUDE_TsnFailureCode*/
#ifndef OPCUA_EXCLUDE_TsnListenerStatus
/*============================================================================
 * The TsnListenerStatus enumeration.
 *===========================================================================*/
enum TsnListenerStatus
{
    TsnListenerStatus_None = 0,
    TsnListenerStatus_Ready = 1,
    TsnListenerStatus_PartialFailed = 2,
    TsnListenerStatus_Failed = 3
#if OPCUA_FORCE_INT32_ENUMS
    ,_TsnListenerStatus_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

OpcUaClassBnm_EXPORT inline void TsnListenerStatus_Clear(TsnListenerStatus *pValue) {*pValue = TsnListenerStatus_None;}

OpcUaClassBnm_EXPORT inline void TsnListenerStatus_Initialize(TsnListenerStatus *pValue) {*pValue = TsnListenerStatus_None;}

OpcUaClassBnm_EXPORT extern struct ::_OpcUa_EnumeratedType TsnListenerStatus_EnumeratedType;

#endif /*OPCUA_EXCLUDE_TsnListenerStatus*/
#ifndef OPCUA_EXCLUDE_TsnStreamState
/*============================================================================
 * The TsnStreamState enumeration.
 *===========================================================================*/
enum TsnStreamState
{
    TsnStreamState_Disabled = 0 /**<The related TSN Stream is currently disabled.*/,
    TsnStreamState_Configuring = 1 /**<The related TSN Stream is in the process of receiving configuration parameters from the TSN Control Layer.*/,
    TsnStreamState_Ready = 2 /**<The related TSN Stream has successfully received and applied the configuration from the TSN Control Layer. The related TSN Stream is not fully operational as long as local preconditions (e.g. synchronization state) are not valid.*/,
    TsnStreamState_Operational = 3 /**<The related TSN Stream object is configured and all other required preconditions (e.g. synchronization state) for sending / receiving data are valid.*/,
    TsnStreamState_Error = 4 /**<The related TSN Stream object is in an error state.*/
#if OPCUA_FORCE_INT32_ENUMS
    ,_TsnStreamState_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

OpcUaClassBnm_EXPORT inline void TsnStreamState_Clear(TsnStreamState *pValue) {*pValue = TsnStreamState_Disabled;}

OpcUaClassBnm_EXPORT inline void TsnStreamState_Initialize(TsnStreamState *pValue) {*pValue = TsnStreamState_Disabled;}

OpcUaClassBnm_EXPORT extern struct ::_OpcUa_EnumeratedType TsnStreamState_EnumeratedType;

#endif /*OPCUA_EXCLUDE_TsnStreamState*/
#ifndef OPCUA_EXCLUDE_TsnTalkerStatus
/*============================================================================
 * The TsnTalkerStatus enumeration.
 *===========================================================================*/
enum TsnTalkerStatus
{
    TsnTalkerStatus_None = 0,
    TsnTalkerStatus_Ready = 1,
    TsnTalkerStatus_Failed = 2
#if OPCUA_FORCE_INT32_ENUMS
    ,_TsnTalkerStatus_MaxEnumerationValue = OpcUa_Int32_Max
#endif
};

OpcUaClassBnm_EXPORT inline void TsnTalkerStatus_Clear(TsnTalkerStatus *pValue) {*pValue = TsnTalkerStatus_None;}

OpcUaClassBnm_EXPORT inline void TsnTalkerStatus_Initialize(TsnTalkerStatus *pValue) {*pValue = TsnTalkerStatus_None;}

OpcUaClassBnm_EXPORT extern struct ::_OpcUa_EnumeratedType TsnTalkerStatus_EnumeratedType;

#endif /*OPCUA_EXCLUDE_TsnTalkerStatus*/
}

#ifndef OPCUA_EXCLUDE_OpcUaClassBnm_IetfBaseNetworkInterfaceDataType
/*============================================================================
 * The OpcUaClassBnm_IetfBaseNetworkInterfaceDataType structure.
 *===========================================================================*/
enum OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_OptionalFields
{
    OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_OptionalFields_PhysAddress = 1
};

typedef struct _OpcUaClassBnm_IetfBaseNetworkInterfaceDataType
{
    OpcUa_UInt32 EncodingMask;
    OpcUa_String PhysAddress;
} OpcUaClassBnm_IetfBaseNetworkInterfaceDataType;

OpcUaClassBnm_EXPORT OpcUa_Void OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_Initialize(OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pValue);

OpcUaClassBnm_EXPORT OpcUa_Void OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_Clear(OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pValue);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_GetSize(OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_Encode(OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pValue, struct _OpcUa_Encoder* pEncoder);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_Decode(OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
OpcUaClassBnm_EXPORT OpcUa_Int        OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_Compare(const OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pValue1, const OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_Copy(const OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pSource, OpcUaClassBnm_IetfBaseNetworkInterfaceDataType** ppCopy);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_CopyTo(const OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pSource, OpcUaClassBnm_IetfBaseNetworkInterfaceDataType* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType OpcUaClassBnm_IetfBaseNetworkInterfaceDataType_EncodeableType;
#endif /*OPCUA_EXCLUDE_OpcUaClassBnm_IetfBaseNetworkInterfaceDataType*/

#ifndef OPCUA_EXCLUDE_OpcUaClassBnm_TsnStreamFailureSystemIdentifier
/*============================================================================
 * The OpcUaClassBnm_TsnStreamFailureSystemIdentifier structure.
 *===========================================================================*/
typedef struct _OpcUaClassBnm_TsnStreamFailureSystemIdentifier
{
    OpcUa_Int32 NoOfSystemIdentifier;
    OpcUa_Byte* SystemIdentifier;
} OpcUaClassBnm_TsnStreamFailureSystemIdentifier;

OpcUaClassBnm_EXPORT OpcUa_Void OpcUaClassBnm_TsnStreamFailureSystemIdentifier_Initialize(OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pValue);

OpcUaClassBnm_EXPORT OpcUa_Void OpcUaClassBnm_TsnStreamFailureSystemIdentifier_Clear(OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pValue);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_TsnStreamFailureSystemIdentifier_GetSize(OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_TsnStreamFailureSystemIdentifier_Encode(OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pValue, struct _OpcUa_Encoder* pEncoder);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_TsnStreamFailureSystemIdentifier_Decode(OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
OpcUaClassBnm_EXPORT OpcUa_Int        OpcUaClassBnm_TsnStreamFailureSystemIdentifier_Compare(const OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pValue1, const OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_TsnStreamFailureSystemIdentifier_Copy(const OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pSource, OpcUaClassBnm_TsnStreamFailureSystemIdentifier** ppCopy);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_TsnStreamFailureSystemIdentifier_CopyTo(const OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pSource, OpcUaClassBnm_TsnStreamFailureSystemIdentifier* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType OpcUaClassBnm_TsnStreamFailureSystemIdentifier_EncodeableType;
#endif /*OPCUA_EXCLUDE_OpcUaClassBnm_TsnStreamFailureSystemIdentifier*/

#ifndef OPCUA_EXCLUDE_OpcUaClassBnm_UnsignedRationalNumber
/*============================================================================
 * The OpcUaClassBnm_UnsignedRationalNumber structure.
 *===========================================================================*/
typedef struct _OpcUaClassBnm_UnsignedRationalNumber
{
    OpcUa_UInt32 Numerator;/**< The top number of the fraction.*/
    OpcUa_UInt32 Denominator;/**< The bottom number of the fraction.*/
} OpcUaClassBnm_UnsignedRationalNumber;

OpcUaClassBnm_EXPORT OpcUa_Void OpcUaClassBnm_UnsignedRationalNumber_Initialize(OpcUaClassBnm_UnsignedRationalNumber* pValue);

OpcUaClassBnm_EXPORT OpcUa_Void OpcUaClassBnm_UnsignedRationalNumber_Clear(OpcUaClassBnm_UnsignedRationalNumber* pValue);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_UnsignedRationalNumber_GetSize(OpcUaClassBnm_UnsignedRationalNumber* pValue, struct _OpcUa_Encoder* pEncoder, OpcUa_Int32* pSize);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_UnsignedRationalNumber_Encode(OpcUaClassBnm_UnsignedRationalNumber* pValue, struct _OpcUa_Encoder* pEncoder);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_UnsignedRationalNumber_Decode(OpcUaClassBnm_UnsignedRationalNumber* pValue, struct _OpcUa_Decoder* pDecoder);

#if OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED
OpcUaClassBnm_EXPORT OpcUa_Int        OpcUaClassBnm_UnsignedRationalNumber_Compare(const OpcUaClassBnm_UnsignedRationalNumber* pValue1, const OpcUaClassBnm_UnsignedRationalNumber* pValue2);
#endif /* OPCUA_ENCODEABLE_OBJECT_COMPARE_SUPPORTED */

#if OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED
OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_UnsignedRationalNumber_Copy(const OpcUaClassBnm_UnsignedRationalNumber* pSource, OpcUaClassBnm_UnsignedRationalNumber** ppCopy);

OpcUaClassBnm_EXPORT OpcUa_StatusCode OpcUaClassBnm_UnsignedRationalNumber_CopyTo(const OpcUaClassBnm_UnsignedRationalNumber* pSource, OpcUaClassBnm_UnsignedRationalNumber* pDestination);
#endif /* OPCUA_ENCODEABLE_OBJECT_COPY_SUPPORTED */

extern struct _OpcUa_EncodeableType OpcUaClassBnm_UnsignedRationalNumber_EncodeableType;
#endif /*OPCUA_EXCLUDE_OpcUaClassBnm_UnsignedRationalNumber*/


/*============================================================================
 * Table of known types.
 *===========================================================================*/
extern struct _OpcUa_EncodeableType** OpcUaClassBnm_KnownEncodeableTypes;

/*============================================================================
 * Register known types.
 *===========================================================================*/
namespace OpcUaClassBnm
{
    /** Class used to handle data type registration
    */
    class DataTypes
    {
    public:
        static void registerStructuredTypes();
    private:
        static bool s_dataTypesAdded;
    };
}

#endif // __OPCUACLASSBNM_DATATYPES_H__

