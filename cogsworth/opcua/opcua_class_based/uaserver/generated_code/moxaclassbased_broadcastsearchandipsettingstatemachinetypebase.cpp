/******************************************************************************
** moxaclassbased_broadcastsearchandipsettingstatemachinetypebase.cpp
**
**   **************************** auto-generated ****************************
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.8.0, using C++ OPC UA SDK 1.8.2 template (version 4)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
**   **************************** auto-generated ****************************
**
** Copyright (c) 2006-2025 Unified Automation GmbH. All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
** Project: C++ OPC Server SDK information model for namespace http://www.moxa.com/auto-configuration-tool-class-based-model/
**
** Description: OPC Unified Architecture Software Development Kit.
**
******************************************************************************/

#include "moxaclassbased_broadcastsearchandipsettingstatemachinetypebase.h"
#include "moxaclassbased_broadcastsearchandipsettingstatemachinetype.h"
#include "uagenericnodes.h"
#include "nodemanagerroot.h"
#include "methodhandleuanode.h"
#include "moxaclassbased_nodemanagermoxaclassbasedns.h"

#include "instancefactory.h"
#include "opcua_extensionobject.h"
#include "opcua_finitestatevariabletype.h"
#include "opcua_finitetransitionvariabletype.h"
// Namespace for the UA information model http://www.moxa.com/auto-configuration-tool-class-based-model/
namespace MoxaClassBased {

bool BroadcastSearchAndIPSettingStateMachineTypeBase::s_typeNodesCreated = false;
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pGetDiscoveredDevicesMethod = NULL;
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pStartDeviceDiscoveryMethod = NULL;
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pStartInitMethod = NULL;
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pStartIpConfigureMethod = NULL;
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pStartLinkSequenceDetectMethod = NULL;
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pStartRetryConnectionMethod = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDeviceDiscovered = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDeviceDiscoveredToInit = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDeviceDiscoveredToLinkSequenceDetecting = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDeviceDiscoveredToRetryConnection = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDeviceDiscovering = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDeviceDiscoveringFailed = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDeviceDiscoveringFailedToInit = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDeviceDiscoveringToDeviceDiscovered = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDeviceDiscoveringToDeviceDiscoveringFailed = NULL;
OpcUa::FolderType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pDiscoveredDevices = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pInit = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pInitToDeviceDiscovering = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pIpConfigured = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pIpConfiguredToInit = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pIpConfiguring = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pIpConfiguringFailed = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pIpConfiguringFailedToInit = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pIpConfiguringFailedToIpConfiguring = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pIpConfiguringToIpConfigured = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pIpConfiguringToIpConfiguringFailed = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetected = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetectedToInit = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetectedToIpConfiguring = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetecting = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetectingFailed = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetectingFailedToInit = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetectingFailedToIpConfiguring = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetectingFailedToRetryConnection = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetectingToLinkSequenceDetected = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pLinkSequenceDetectingToLinkSequenceDetectingFailed = NULL;
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pRetryConnection = NULL;
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pRetryConnectionToDeviceDiscovered = NULL;
OpcUa::BaseDataVariableType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pErrorCode = NULL;
OpcUa::BaseDataVariableType* BroadcastSearchAndIPSettingStateMachineTypeBase::s_pErrorMessage = NULL;

/** Constructs an BroadcastSearchAndIPSettingStateMachineType object using an instance declaration node as base
*/
BroadcastSearchAndIPSettingStateMachineTypeBase::BroadcastSearchAndIPSettingStateMachineTypeBase(const UaNodeId& nodeId, UaObject* pInstanceDeclarationObject, NodeManagerConfig* pNodeConfig, UaMutexRefCounted* pSharedMutex)
: OpcUa::FiniteStateMachineType(nodeId, pInstanceDeclarationObject, pNodeConfig, pSharedMutex)
{
    initialize();
}

/** Constructs an BroadcastSearchAndIPSettingStateMachineType object
*/
BroadcastSearchAndIPSettingStateMachineTypeBase::BroadcastSearchAndIPSettingStateMachineTypeBase(const UaNodeId& nodeId, const UaString& name, OpcUa_UInt16 browseNameNameSpaceIndex, NodeManagerConfig* pNodeConfig, UaMutexRefCounted* pSharedMutex)
: OpcUa::FiniteStateMachineType(nodeId, name, browseNameNameSpaceIndex, pNodeConfig, pSharedMutex)
{
    initialize();
}

/**  Constructs an instance of the class BroadcastSearchAndIPSettingStateMachineTypeBase with all components
*/
BroadcastSearchAndIPSettingStateMachineTypeBase::BroadcastSearchAndIPSettingStateMachineTypeBase(
    UaBase::Object*    pBaseNode,    //!< [in] The "tree" of nodes that specifies the attributes of the instance and its children
    XmlUaNodeFactoryManager* pFactory, //!< [in] The factory to create the children
    NodeManagerConfig* pNodeConfig,  //!< [in] Interface pointer to the NodeManagerConfig interface used to add and delete node and references in the address space
    UaMutexRefCounted* pSharedMutex) //!< [in] Shared mutex object used to synchronize access to the variable. Can be NULL if no shared mutex is provided
: OpcUa::FiniteStateMachineType(pBaseNode, pFactory, pNodeConfig, pSharedMutex)
{
    UaStatus      addStatus;

    if ( s_typeNodesCreated == false )
    {
        createTypes();
    }

    m_pDeviceDiscovered = NULL;
    m_pDeviceDiscoveredToInit = NULL;
    m_pDeviceDiscoveredToLinkSequenceDetecting = NULL;
    m_pDeviceDiscoveredToRetryConnection = NULL;
    m_pDeviceDiscovering = NULL;
    m_pDeviceDiscoveringFailed = NULL;
    m_pDeviceDiscoveringFailedToInit = NULL;
    m_pDeviceDiscoveringToDeviceDiscovered = NULL;
    m_pDeviceDiscoveringToDeviceDiscoveringFailed = NULL;
    m_pDiscoveredDevices = NULL;
    m_pInit = NULL;
    m_pInitToDeviceDiscovering = NULL;
    m_pIpConfigured = NULL;
    m_pIpConfiguredToInit = NULL;
    m_pIpConfiguring = NULL;
    m_pIpConfiguringFailed = NULL;
    m_pIpConfiguringFailedToInit = NULL;
    m_pIpConfiguringFailedToIpConfiguring = NULL;
    m_pIpConfiguringToIpConfigured = NULL;
    m_pIpConfiguringToIpConfiguringFailed = NULL;
    m_pLinkSequenceDetected = NULL;
    m_pLinkSequenceDetectedToInit = NULL;
    m_pLinkSequenceDetectedToIpConfiguring = NULL;
    m_pLinkSequenceDetecting = NULL;
    m_pLinkSequenceDetectingFailed = NULL;
    m_pLinkSequenceDetectingFailedToInit = NULL;
    m_pLinkSequenceDetectingFailedToIpConfiguring = NULL;
    m_pLinkSequenceDetectingFailedToRetryConnection = NULL;
    m_pLinkSequenceDetectingToLinkSequenceDetected = NULL;
    m_pLinkSequenceDetectingToLinkSequenceDetectingFailed = NULL;
    m_pRetryConnection = NULL;
    m_pRetryConnectionToDeviceDiscovered = NULL;
    m_pErrorCode = NULL;
    m_pErrorMessage = NULL;
    m_pGetDiscoveredDevicesMethod = NULL;
    m_pStartDeviceDiscoveryMethod = NULL;
    m_pStartInitMethod = NULL;
    m_pStartIpConfigureMethod = NULL;
    m_pStartLinkSequenceDetectMethod = NULL;
    m_pStartRetryConnectionMethod = NULL;

    std::list<UaBase::BaseNode*> lstReferencedNodes = pBaseNode->hierarchicallyReferencedNodes();
    for (std::list<UaBase::BaseNode*>::const_iterator it = lstReferencedNodes.begin(); it != lstReferencedNodes.end(); it++)
    {
        UaBase::BaseNode *pChild = *it;
        if (pChild->browseName() == UaQualifiedName("ErrorCode", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pErrorCode)
            {
                m_pErrorCode = (OpcUa::BaseDataVariableType*) pFactory->createVariable((UaBase::Variable*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pErrorCode, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Variable*)pChild)->modellingRuleId().isNull())
                {
                    m_pErrorCode->setModellingRuleId(((UaBase::Variable*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("ErrorMessage", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pErrorMessage)
            {
                m_pErrorMessage = (OpcUa::BaseDataVariableType*) pFactory->createVariable((UaBase::Variable*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pErrorMessage, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Variable*)pChild)->modellingRuleId().isNull())
                {
                    m_pErrorMessage->setModellingRuleId(((UaBase::Variable*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DeviceDiscovered", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDeviceDiscovered)
            {
                m_pDeviceDiscovered = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDeviceDiscovered, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDeviceDiscovered->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DeviceDiscoveredToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDeviceDiscoveredToInit)
            {
                m_pDeviceDiscoveredToInit = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveredToInit, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDeviceDiscoveredToInit->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DeviceDiscoveredToLinkSequenceDetecting", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDeviceDiscoveredToLinkSequenceDetecting)
            {
                m_pDeviceDiscoveredToLinkSequenceDetecting = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveredToLinkSequenceDetecting, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDeviceDiscoveredToLinkSequenceDetecting->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DeviceDiscoveredToRetryConnection", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDeviceDiscoveredToRetryConnection)
            {
                m_pDeviceDiscoveredToRetryConnection = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveredToRetryConnection, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDeviceDiscoveredToRetryConnection->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DeviceDiscovering", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDeviceDiscovering)
            {
                m_pDeviceDiscovering = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDeviceDiscovering, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDeviceDiscovering->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DeviceDiscoveringFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDeviceDiscoveringFailed)
            {
                m_pDeviceDiscoveringFailed = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveringFailed, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDeviceDiscoveringFailed->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DeviceDiscoveringFailedToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDeviceDiscoveringFailedToInit)
            {
                m_pDeviceDiscoveringFailedToInit = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveringFailedToInit, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDeviceDiscoveringFailedToInit->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DeviceDiscoveringToDeviceDiscovered", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDeviceDiscoveringToDeviceDiscovered)
            {
                m_pDeviceDiscoveringToDeviceDiscovered = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveringToDeviceDiscovered, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDeviceDiscoveringToDeviceDiscovered->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DeviceDiscoveringToDeviceDiscoveringFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDeviceDiscoveringToDeviceDiscoveringFailed)
            {
                m_pDeviceDiscoveringToDeviceDiscoveringFailed = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveringToDeviceDiscoveringFailed, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDeviceDiscoveringToDeviceDiscoveringFailed->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("DiscoveredDevices", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pDiscoveredDevices)
            {
                m_pDiscoveredDevices = (OpcUa::FolderType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pDiscoveredDevices, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pDiscoveredDevices->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("Init", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pInit)
            {
                m_pInit = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pInit, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pInit->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("InitToDeviceDiscovering", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pInitToDeviceDiscovering)
            {
                m_pInitToDeviceDiscovering = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pInitToDeviceDiscovering, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pInitToDeviceDiscovering->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("IpConfigured", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pIpConfigured)
            {
                m_pIpConfigured = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pIpConfigured, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pIpConfigured->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("IpConfiguredToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pIpConfiguredToInit)
            {
                m_pIpConfiguredToInit = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pIpConfiguredToInit, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pIpConfiguredToInit->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("IpConfiguring", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pIpConfiguring)
            {
                m_pIpConfiguring = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pIpConfiguring, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pIpConfiguring->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("IpConfiguringFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pIpConfiguringFailed)
            {
                m_pIpConfiguringFailed = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pIpConfiguringFailed, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pIpConfiguringFailed->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("IpConfiguringFailedToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pIpConfiguringFailedToInit)
            {
                m_pIpConfiguringFailedToInit = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pIpConfiguringFailedToInit, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pIpConfiguringFailedToInit->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("IpConfiguringFailedToIpConfiguring", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pIpConfiguringFailedToIpConfiguring)
            {
                m_pIpConfiguringFailedToIpConfiguring = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pIpConfiguringFailedToIpConfiguring, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pIpConfiguringFailedToIpConfiguring->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("IpConfiguringToIpConfigured", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pIpConfiguringToIpConfigured)
            {
                m_pIpConfiguringToIpConfigured = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pIpConfiguringToIpConfigured, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pIpConfiguringToIpConfigured->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("IpConfiguringToIpConfiguringFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pIpConfiguringToIpConfiguringFailed)
            {
                m_pIpConfiguringToIpConfiguringFailed = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pIpConfiguringToIpConfiguringFailed, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pIpConfiguringToIpConfiguringFailed->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetected", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetected)
            {
                m_pLinkSequenceDetected = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetected, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetected->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetectedToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetectedToInit)
            {
                m_pLinkSequenceDetectedToInit = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectedToInit, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetectedToInit->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetectedToIpConfiguring", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetectedToIpConfiguring)
            {
                m_pLinkSequenceDetectedToIpConfiguring = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectedToIpConfiguring, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetectedToIpConfiguring->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetecting", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetecting)
            {
                m_pLinkSequenceDetecting = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetecting, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetecting->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetectingFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetectingFailed)
            {
                m_pLinkSequenceDetectingFailed = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingFailed, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetectingFailed->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetectingFailedToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetectingFailedToInit)
            {
                m_pLinkSequenceDetectingFailedToInit = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingFailedToInit, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetectingFailedToInit->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetectingFailedToIpConfiguring", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetectingFailedToIpConfiguring)
            {
                m_pLinkSequenceDetectingFailedToIpConfiguring = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingFailedToIpConfiguring, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetectingFailedToIpConfiguring->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetectingFailedToRetryConnection", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetectingFailedToRetryConnection)
            {
                m_pLinkSequenceDetectingFailedToRetryConnection = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingFailedToRetryConnection, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetectingFailedToRetryConnection->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetectingToLinkSequenceDetected", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetectingToLinkSequenceDetected)
            {
                m_pLinkSequenceDetectingToLinkSequenceDetected = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingToLinkSequenceDetected, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetectingToLinkSequenceDetected->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("LinkSequenceDetectingToLinkSequenceDetectingFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pLinkSequenceDetectingToLinkSequenceDetectingFailed)
            {
                m_pLinkSequenceDetectingToLinkSequenceDetectingFailed = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingToLinkSequenceDetectingFailed, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pLinkSequenceDetectingToLinkSequenceDetectingFailed->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("RetryConnection", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pRetryConnection)
            {
                m_pRetryConnection = (OpcUa::StateType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pRetryConnection, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pRetryConnection->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (pChild->browseName() == UaQualifiedName("RetryConnectionToDeviceDiscovered", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()))
        {
            if (!m_pRetryConnectionToDeviceDiscovered)
            {
                m_pRetryConnectionToDeviceDiscovered = (OpcUa::TransitionType*) pFactory->createObject((UaBase::Object*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pRetryConnectionToDeviceDiscovered, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Object*)pChild)->modellingRuleId().isNull())
                {
                    m_pRetryConnectionToDeviceDiscovered->setModellingRuleId(((UaBase::Object*)pChild)->modellingRuleId());
                }
            }
        }
        else if (s_pGetDiscoveredDevicesMethod && pChild->browseName() == s_pGetDiscoveredDevicesMethod->browseName())
        {
            if (!m_pGetDiscoveredDevicesMethod)
            {
                m_pGetDiscoveredDevicesMethod = (OpcUa::BaseMethod*) pFactory->createMethod((UaBase::Method*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pGetDiscoveredDevicesMethod, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Method*)pChild)->modellingRuleId().isNull())
                {
                    m_pGetDiscoveredDevicesMethod->setModellingRuleId(((UaBase::Method*)pChild)->modellingRuleId());
                }
            }
        }
        else if (s_pStartDeviceDiscoveryMethod && pChild->browseName() == s_pStartDeviceDiscoveryMethod->browseName())
        {
            if (!m_pStartDeviceDiscoveryMethod)
            {
                m_pStartDeviceDiscoveryMethod = (OpcUa::BaseMethod*) pFactory->createMethod((UaBase::Method*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pStartDeviceDiscoveryMethod, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Method*)pChild)->modellingRuleId().isNull())
                {
                    m_pStartDeviceDiscoveryMethod->setModellingRuleId(((UaBase::Method*)pChild)->modellingRuleId());
                }
            }
        }
        else if (s_pStartInitMethod && pChild->browseName() == s_pStartInitMethod->browseName())
        {
            if (!m_pStartInitMethod)
            {
                m_pStartInitMethod = (OpcUa::BaseMethod*) pFactory->createMethod((UaBase::Method*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pStartInitMethod, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Method*)pChild)->modellingRuleId().isNull())
                {
                    m_pStartInitMethod->setModellingRuleId(((UaBase::Method*)pChild)->modellingRuleId());
                }
            }
        }
        else if (s_pStartIpConfigureMethod && pChild->browseName() == s_pStartIpConfigureMethod->browseName())
        {
            if (!m_pStartIpConfigureMethod)
            {
                m_pStartIpConfigureMethod = (OpcUa::BaseMethod*) pFactory->createMethod((UaBase::Method*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pStartIpConfigureMethod, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Method*)pChild)->modellingRuleId().isNull())
                {
                    m_pStartIpConfigureMethod->setModellingRuleId(((UaBase::Method*)pChild)->modellingRuleId());
                }
            }
        }
        else if (s_pStartLinkSequenceDetectMethod && pChild->browseName() == s_pStartLinkSequenceDetectMethod->browseName())
        {
            if (!m_pStartLinkSequenceDetectMethod)
            {
                m_pStartLinkSequenceDetectMethod = (OpcUa::BaseMethod*) pFactory->createMethod((UaBase::Method*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pStartLinkSequenceDetectMethod, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Method*)pChild)->modellingRuleId().isNull())
                {
                    m_pStartLinkSequenceDetectMethod->setModellingRuleId(((UaBase::Method*)pChild)->modellingRuleId());
                }
            }
        }
        else if (s_pStartRetryConnectionMethod && pChild->browseName() == s_pStartRetryConnectionMethod->browseName())
        {
            if (!m_pStartRetryConnectionMethod)
            {
                m_pStartRetryConnectionMethod = (OpcUa::BaseMethod*) pFactory->createMethod((UaBase::Method*)pChild, pNodeConfig, pSharedMutex);
                addStatus = pNodeConfig->addNodeAndReference(this, m_pStartRetryConnectionMethod, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
                if (!((UaBase::Method*)pChild)->modellingRuleId().isNull())
                {
                    m_pStartRetryConnectionMethod->setModellingRuleId(((UaBase::Method*)pChild)->modellingRuleId());
                }
            }
        }
    }
    UA_ASSERT(m_pDeviceDiscovered);
    UA_ASSERT(m_pDeviceDiscoveredToInit);
    UA_ASSERT(m_pDeviceDiscoveredToLinkSequenceDetecting);
    UA_ASSERT(m_pDeviceDiscoveredToRetryConnection);
    UA_ASSERT(m_pDeviceDiscovering);
    UA_ASSERT(m_pDeviceDiscoveringFailed);
    UA_ASSERT(m_pDeviceDiscoveringFailedToInit);
    UA_ASSERT(m_pDeviceDiscoveringToDeviceDiscovered);
    UA_ASSERT(m_pDeviceDiscoveringToDeviceDiscoveringFailed);
    UA_ASSERT(m_pDiscoveredDevices);
    UA_ASSERT(m_pInit);
    UA_ASSERT(m_pInitToDeviceDiscovering);
    UA_ASSERT(m_pIpConfigured);
    UA_ASSERT(m_pIpConfiguredToInit);
    UA_ASSERT(m_pIpConfiguring);
    UA_ASSERT(m_pIpConfiguringFailed);
    UA_ASSERT(m_pIpConfiguringFailedToInit);
    UA_ASSERT(m_pIpConfiguringFailedToIpConfiguring);
    UA_ASSERT(m_pIpConfiguringToIpConfigured);
    UA_ASSERT(m_pIpConfiguringToIpConfiguringFailed);
    UA_ASSERT(m_pLinkSequenceDetected);
    UA_ASSERT(m_pLinkSequenceDetectedToInit);
    UA_ASSERT(m_pLinkSequenceDetectedToIpConfiguring);
    UA_ASSERT(m_pLinkSequenceDetecting);
    UA_ASSERT(m_pLinkSequenceDetectingFailed);
    UA_ASSERT(m_pLinkSequenceDetectingFailedToInit);
    UA_ASSERT(m_pLinkSequenceDetectingFailedToIpConfiguring);
    UA_ASSERT(m_pLinkSequenceDetectingFailedToRetryConnection);
    UA_ASSERT(m_pLinkSequenceDetectingToLinkSequenceDetected);
    UA_ASSERT(m_pLinkSequenceDetectingToLinkSequenceDetectingFailed);
    UA_ASSERT(m_pRetryConnection);
    UA_ASSERT(m_pRetryConnectionToDeviceDiscovered);
    UA_ASSERT(m_pErrorCode);
    UA_ASSERT(m_pErrorMessage);
    UA_ASSERT(m_pGetDiscoveredDevicesMethod);
    UA_ASSERT(m_pStartDeviceDiscoveryMethod);
    UA_ASSERT(m_pStartInitMethod);
    UA_ASSERT(m_pStartIpConfigureMethod);
    UA_ASSERT(m_pStartLinkSequenceDetectMethod);
    UA_ASSERT(m_pStartRetryConnectionMethod);
}

/** Initialize the object with all member nodes
*/
void BroadcastSearchAndIPSettingStateMachineTypeBase::initialize()
{
    OpcUa_Int16 nsIdx = m_pNodeConfig->getNameSpaceIndex();
    UaStatus      addStatus;
    UaVariant     defaultValue;
    UaUInt32Array arrayDimensions;
    UaPropertyMethodArgument* pPropertyArg = NULL;

    if ( s_typeNodesCreated == false )
    {
        createTypes();
    }
    m_pDeviceDiscovered = NULL;
    m_pDeviceDiscoveredToInit = NULL;
    m_pDeviceDiscoveredToLinkSequenceDetecting = NULL;
    m_pDeviceDiscoveredToRetryConnection = NULL;
    m_pDeviceDiscovering = NULL;
    m_pDeviceDiscoveringFailed = NULL;
    m_pDeviceDiscoveringFailedToInit = NULL;
    m_pDeviceDiscoveringToDeviceDiscovered = NULL;
    m_pDeviceDiscoveringToDeviceDiscoveringFailed = NULL;
    m_pDiscoveredDevices = NULL;
    m_pInit = NULL;
    m_pInitToDeviceDiscovering = NULL;
    m_pIpConfigured = NULL;
    m_pIpConfiguredToInit = NULL;
    m_pIpConfiguring = NULL;
    m_pIpConfiguringFailed = NULL;
    m_pIpConfiguringFailedToInit = NULL;
    m_pIpConfiguringFailedToIpConfiguring = NULL;
    m_pIpConfiguringToIpConfigured = NULL;
    m_pIpConfiguringToIpConfiguringFailed = NULL;
    m_pLinkSequenceDetected = NULL;
    m_pLinkSequenceDetectedToInit = NULL;
    m_pLinkSequenceDetectedToIpConfiguring = NULL;
    m_pLinkSequenceDetecting = NULL;
    m_pLinkSequenceDetectingFailed = NULL;
    m_pLinkSequenceDetectingFailedToInit = NULL;
    m_pLinkSequenceDetectingFailedToIpConfiguring = NULL;
    m_pLinkSequenceDetectingFailedToRetryConnection = NULL;
    m_pLinkSequenceDetectingToLinkSequenceDetected = NULL;
    m_pLinkSequenceDetectingToLinkSequenceDetectingFailed = NULL;
    m_pRetryConnection = NULL;
    m_pRetryConnectionToDeviceDiscovered = NULL;
    m_pErrorCode = NULL;
    m_pErrorMessage = NULL;
    m_pGetDiscoveredDevicesMethod = NULL;
    m_pStartDeviceDiscoveryMethod = NULL;
    m_pStartInitMethod = NULL;
    m_pStartIpConfigureMethod = NULL;
    m_pStartLinkSequenceDetectMethod = NULL;
    m_pStartRetryConnectionMethod = NULL;
    // Object DeviceDiscovered
    m_pDeviceDiscovered = new OpcUa::StateType(UaNodeId(UaString("%1.DeviceDiscovered").arg(nodeId().toString()), nsIdx), s_pDeviceDiscovered, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDeviceDiscovered, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object DeviceDiscoveredToInit
    m_pDeviceDiscoveredToInit = new OpcUa::TransitionType(UaNodeId(UaString("%1.DeviceDiscoveredToInit").arg(nodeId().toString()), nsIdx), s_pDeviceDiscoveredToInit, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveredToInit, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object DeviceDiscoveredToLinkSequenceDetecting
    m_pDeviceDiscoveredToLinkSequenceDetecting = new OpcUa::TransitionType(UaNodeId(UaString("%1.DeviceDiscoveredToLinkSequenceDetecting").arg(nodeId().toString()), nsIdx), s_pDeviceDiscoveredToLinkSequenceDetecting, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveredToLinkSequenceDetecting, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object DeviceDiscoveredToRetryConnection
    m_pDeviceDiscoveredToRetryConnection = new OpcUa::TransitionType(UaNodeId(UaString("%1.DeviceDiscoveredToRetryConnection").arg(nodeId().toString()), nsIdx), s_pDeviceDiscoveredToRetryConnection, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveredToRetryConnection, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object DeviceDiscovering
    m_pDeviceDiscovering = new OpcUa::StateType(UaNodeId(UaString("%1.DeviceDiscovering").arg(nodeId().toString()), nsIdx), s_pDeviceDiscovering, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDeviceDiscovering, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object DeviceDiscoveringFailed
    m_pDeviceDiscoveringFailed = new OpcUa::StateType(UaNodeId(UaString("%1.DeviceDiscoveringFailed").arg(nodeId().toString()), nsIdx), s_pDeviceDiscoveringFailed, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveringFailed, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object DeviceDiscoveringFailedToInit
    m_pDeviceDiscoveringFailedToInit = new OpcUa::TransitionType(UaNodeId(UaString("%1.DeviceDiscoveringFailedToInit").arg(nodeId().toString()), nsIdx), s_pDeviceDiscoveringFailedToInit, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveringFailedToInit, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object DeviceDiscoveringToDeviceDiscovered
    m_pDeviceDiscoveringToDeviceDiscovered = new OpcUa::TransitionType(UaNodeId(UaString("%1.DeviceDiscoveringToDeviceDiscovered").arg(nodeId().toString()), nsIdx), s_pDeviceDiscoveringToDeviceDiscovered, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveringToDeviceDiscovered, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object DeviceDiscoveringToDeviceDiscoveringFailed
    m_pDeviceDiscoveringToDeviceDiscoveringFailed = new OpcUa::TransitionType(UaNodeId(UaString("%1.DeviceDiscoveringToDeviceDiscoveringFailed").arg(nodeId().toString()), nsIdx), s_pDeviceDiscoveringToDeviceDiscoveringFailed, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDeviceDiscoveringToDeviceDiscoveringFailed, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object DiscoveredDevices
    m_pDiscoveredDevices = new OpcUa::FolderType(UaNodeId(UaString("%1.DiscoveredDevices").arg(nodeId().toString()), nsIdx), s_pDiscoveredDevices, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pDiscoveredDevices, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Mandatory variable ErrorCode
    m_pErrorCode = new OpcUa::BaseDataVariableType(this, s_pErrorCode, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pErrorCode, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());

    // Mandatory variable ErrorMessage
    m_pErrorMessage = new OpcUa::BaseDataVariableType(this, s_pErrorMessage, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pErrorMessage, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());

    // Object Init
    m_pInit = new OpcUa::StateType(UaNodeId(UaString("%1.Init").arg(nodeId().toString()), nsIdx), s_pInit, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pInit, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object InitToDeviceDiscovering
    m_pInitToDeviceDiscovering = new OpcUa::TransitionType(UaNodeId(UaString("%1.InitToDeviceDiscovering").arg(nodeId().toString()), nsIdx), s_pInitToDeviceDiscovering, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pInitToDeviceDiscovering, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object IpConfigured
    m_pIpConfigured = new OpcUa::StateType(UaNodeId(UaString("%1.IpConfigured").arg(nodeId().toString()), nsIdx), s_pIpConfigured, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pIpConfigured, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object IpConfiguredToInit
    m_pIpConfiguredToInit = new OpcUa::TransitionType(UaNodeId(UaString("%1.IpConfiguredToInit").arg(nodeId().toString()), nsIdx), s_pIpConfiguredToInit, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pIpConfiguredToInit, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object IpConfiguring
    m_pIpConfiguring = new OpcUa::StateType(UaNodeId(UaString("%1.IpConfiguring").arg(nodeId().toString()), nsIdx), s_pIpConfiguring, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pIpConfiguring, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object IpConfiguringFailed
    m_pIpConfiguringFailed = new OpcUa::StateType(UaNodeId(UaString("%1.IpConfiguringFailed").arg(nodeId().toString()), nsIdx), s_pIpConfiguringFailed, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pIpConfiguringFailed, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object IpConfiguringFailedToInit
    m_pIpConfiguringFailedToInit = new OpcUa::TransitionType(UaNodeId(UaString("%1.IpConfiguringFailedToInit").arg(nodeId().toString()), nsIdx), s_pIpConfiguringFailedToInit, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pIpConfiguringFailedToInit, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object IpConfiguringFailedToIpConfiguring
    m_pIpConfiguringFailedToIpConfiguring = new OpcUa::TransitionType(UaNodeId(UaString("%1.IpConfiguringFailedToIpConfiguring").arg(nodeId().toString()), nsIdx), s_pIpConfiguringFailedToIpConfiguring, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pIpConfiguringFailedToIpConfiguring, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object IpConfiguringToIpConfigured
    m_pIpConfiguringToIpConfigured = new OpcUa::TransitionType(UaNodeId(UaString("%1.IpConfiguringToIpConfigured").arg(nodeId().toString()), nsIdx), s_pIpConfiguringToIpConfigured, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pIpConfiguringToIpConfigured, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object IpConfiguringToIpConfiguringFailed
    m_pIpConfiguringToIpConfiguringFailed = new OpcUa::TransitionType(UaNodeId(UaString("%1.IpConfiguringToIpConfiguringFailed").arg(nodeId().toString()), nsIdx), s_pIpConfiguringToIpConfiguringFailed, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pIpConfiguringToIpConfiguringFailed, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetected
    m_pLinkSequenceDetected = new OpcUa::StateType(UaNodeId(UaString("%1.LinkSequenceDetected").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetected, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetected, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetectedToInit
    m_pLinkSequenceDetectedToInit = new OpcUa::TransitionType(UaNodeId(UaString("%1.LinkSequenceDetectedToInit").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetectedToInit, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectedToInit, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetectedToIpConfiguring
    m_pLinkSequenceDetectedToIpConfiguring = new OpcUa::TransitionType(UaNodeId(UaString("%1.LinkSequenceDetectedToIpConfiguring").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetectedToIpConfiguring, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectedToIpConfiguring, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetecting
    m_pLinkSequenceDetecting = new OpcUa::StateType(UaNodeId(UaString("%1.LinkSequenceDetecting").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetecting, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetecting, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetectingFailed
    m_pLinkSequenceDetectingFailed = new OpcUa::StateType(UaNodeId(UaString("%1.LinkSequenceDetectingFailed").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetectingFailed, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingFailed, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetectingFailedToInit
    m_pLinkSequenceDetectingFailedToInit = new OpcUa::TransitionType(UaNodeId(UaString("%1.LinkSequenceDetectingFailedToInit").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetectingFailedToInit, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingFailedToInit, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetectingFailedToIpConfiguring
    m_pLinkSequenceDetectingFailedToIpConfiguring = new OpcUa::TransitionType(UaNodeId(UaString("%1.LinkSequenceDetectingFailedToIpConfiguring").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetectingFailedToIpConfiguring, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingFailedToIpConfiguring, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetectingFailedToRetryConnection
    m_pLinkSequenceDetectingFailedToRetryConnection = new OpcUa::TransitionType(UaNodeId(UaString("%1.LinkSequenceDetectingFailedToRetryConnection").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetectingFailedToRetryConnection, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingFailedToRetryConnection, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetectingToLinkSequenceDetected
    m_pLinkSequenceDetectingToLinkSequenceDetected = new OpcUa::TransitionType(UaNodeId(UaString("%1.LinkSequenceDetectingToLinkSequenceDetected").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetectingToLinkSequenceDetected, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingToLinkSequenceDetected, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object LinkSequenceDetectingToLinkSequenceDetectingFailed
    m_pLinkSequenceDetectingToLinkSequenceDetectingFailed = new OpcUa::TransitionType(UaNodeId(UaString("%1.LinkSequenceDetectingToLinkSequenceDetectingFailed").arg(nodeId().toString()), nsIdx), s_pLinkSequenceDetectingToLinkSequenceDetectingFailed, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pLinkSequenceDetectingToLinkSequenceDetectingFailed, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object RetryConnection
    m_pRetryConnection = new OpcUa::StateType(UaNodeId(UaString("%1.RetryConnection").arg(nodeId().toString()), nsIdx), s_pRetryConnection, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pRetryConnection, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // Object RetryConnectionToDeviceDiscovered
    m_pRetryConnectionToDeviceDiscovered = new OpcUa::TransitionType(UaNodeId(UaString("%1.RetryConnectionToDeviceDiscovered").arg(nodeId().toString()), nsIdx), s_pRetryConnectionToDeviceDiscovered, m_pNodeConfig, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pRetryConnectionToDeviceDiscovered, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());

    // Method GetDiscoveredDevices
    m_pGetDiscoveredDevicesMethod = new OpcUa::BaseMethod(this, s_pGetDiscoveredDevicesMethod, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pGetDiscoveredDevicesMethod, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // ------------------------------------------------------------------------
    // Add OutputArguments
    // Create property
    pPropertyArg = new UaPropertyMethodArgument(
        UaNodeId(UaString("%1.GetDiscoveredDevices.OutputArguments").arg(nodeId().toString()), nsIdx), // NodeId of the property
        OpcUa_AccessLevels_CurrentRead,          // Access level of the property
        1,                                      // Number of arguments
        UaPropertyMethodArgument::OUTARGUMENTS); // OUT arguments
    // Argument DiscoveredDevices
    arrayDimensions.create(1);
    arrayDimensions[0] = 0;
    pPropertyArg->setArgument(
        0,                      // Index of the argument
        "DiscoveredDevices",             // Name of the argument
        UaNodeId(MoxaClassBasedId_DiscoveredDeviceDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
        1,                     // ValueRank of the argument
        arrayDimensions,
        UaLocalizedText("", "")); // Description
    // Add property to method
    addStatus = m_pNodeConfig->addNodeAndReference(m_pGetDiscoveredDevicesMethod, pPropertyArg, OpcUaId_HasProperty);
    UA_ASSERT(addStatus.isGood());

    // Method StartDeviceDiscovery
    m_pStartDeviceDiscoveryMethod = new OpcUa::BaseMethod(this, s_pStartDeviceDiscoveryMethod, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pStartDeviceDiscoveryMethod, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // ------------------------------------------------------------------------
    // Add InputArguments
    // Create property
    pPropertyArg = new UaPropertyMethodArgument(
        UaNodeId(UaString("%1.StartDeviceDiscovery.InputArguments").arg(nodeId().toString()), nsIdx), // NodeId of the property
        OpcUa_AccessLevels_CurrentRead,         // Access level of the property
        1,                                      // Number of arguments
        UaPropertyMethodArgument::INARGUMENTS); // IN arguments
    // Argument Configuration
    pPropertyArg->setArgument(
        0,                      // Index of the argument
        "Configuration",             // Name of the argument
        UaNodeId(MoxaClassBasedId_DeviceDiscoveryDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
        -1,                     // ValueRank of the argument
        arrayDimensions,
        UaLocalizedText("", "")); // Description
    // Add property to method
    addStatus = m_pNodeConfig->addNodeAndReference(m_pStartDeviceDiscoveryMethod, pPropertyArg, OpcUaId_HasProperty);
    UA_ASSERT(addStatus.isGood());

    // Method StartInit
    m_pStartInitMethod = new OpcUa::BaseMethod(this, s_pStartInitMethod, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pStartInitMethod, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());

    // Method StartIpConfigure
    m_pStartIpConfigureMethod = new OpcUa::BaseMethod(this, s_pStartIpConfigureMethod, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pStartIpConfigureMethod, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // ------------------------------------------------------------------------
    // Add InputArguments
    // Create property
    pPropertyArg = new UaPropertyMethodArgument(
        UaNodeId(UaString("%1.StartIpConfigure.InputArguments").arg(nodeId().toString()), nsIdx), // NodeId of the property
        OpcUa_AccessLevels_CurrentRead,         // Access level of the property
        1,                                      // Number of arguments
        UaPropertyMethodArgument::INARGUMENTS); // IN arguments
    // Argument Configuration
    arrayDimensions.create(1);
    arrayDimensions[0] = 0;
    pPropertyArg->setArgument(
        0,                      // Index of the argument
        "Configuration",             // Name of the argument
        UaNodeId(MoxaClassBasedId_IpConfigureDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
        1,                     // ValueRank of the argument
        arrayDimensions,
        UaLocalizedText("", "")); // Description
    // Add property to method
    addStatus = m_pNodeConfig->addNodeAndReference(m_pStartIpConfigureMethod, pPropertyArg, OpcUaId_HasProperty);
    UA_ASSERT(addStatus.isGood());

    // Method StartLinkSequenceDetect
    m_pStartLinkSequenceDetectMethod = new OpcUa::BaseMethod(this, s_pStartLinkSequenceDetectMethod, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pStartLinkSequenceDetectMethod, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());

    // Method StartRetryConnection
    m_pStartRetryConnectionMethod = new OpcUa::BaseMethod(this, s_pStartRetryConnectionMethod, m_pSharedMutex);
    addStatus = m_pNodeConfig->addNodeAndReference(this, m_pStartRetryConnectionMethod, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
    // ------------------------------------------------------------------------
    // Add InputArguments
    // Create property
    pPropertyArg = new UaPropertyMethodArgument(
        UaNodeId(UaString("%1.StartRetryConnection.InputArguments").arg(nodeId().toString()), nsIdx), // NodeId of the property
        OpcUa_AccessLevels_CurrentRead,         // Access level of the property
        2,                                      // Number of arguments
        UaPropertyMethodArgument::INARGUMENTS); // IN arguments
    // Argument SNMP
    pPropertyArg->setArgument(
        0,                      // Index of the argument
        "SNMP",             // Name of the argument
        UaNodeId(MoxaClassBasedId_SNMPDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
        -1,                     // ValueRank of the argument
        arrayDimensions,
        UaLocalizedText("", "")); // Description
    // Argument RESTful
    pPropertyArg->setArgument(
        1,                      // Index of the argument
        "RESTful",             // Name of the argument
        UaNodeId(MoxaClassBasedId_RESTfulDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
        -1,                     // ValueRank of the argument
        arrayDimensions,
        UaLocalizedText("", "")); // Description
    // Add property to method
    addStatus = m_pNodeConfig->addNodeAndReference(m_pStartRetryConnectionMethod, pPropertyArg, OpcUaId_HasProperty);
    UA_ASSERT(addStatus.isGood());

    setCurrentState(s_pDeviceDiscovered->displayName(NULL));
    getCurrentStateNode()->setIdNodeId(s_pDeviceDiscovered->nodeId());
}

/** Destruction
*/
BroadcastSearchAndIPSettingStateMachineTypeBase::~BroadcastSearchAndIPSettingStateMachineTypeBase()
{
}

/** Create the related type nodes
*/
void BroadcastSearchAndIPSettingStateMachineTypeBase::createTypes()
{
    if ( s_typeNodesCreated == false )
    {
        s_typeNodesCreated = true;

        // Check if supertype is already created
        OpcUa::FiniteStateMachineType::createTypes();

        UaStatus      addStatus;
        UaVariant     defaultValue;
        UaUInt32Array arrayDimensions;
        UaPropertyMethodArgument* pPropertyArg = NULL;
        NodeManagerRoot* pNodeManagerRoot = NodeManagerRoot::CreateRootNodeManager();
        OpcUa_Int16 nsTypeIdx = NodeManagerMoxaClassBasedNS::getTypeNamespace();
        OpcUa_Int16 nsSuperTypeIdx = NodeManagerRoot::getTypeNamespace();
        NodeManagerConfig* pTypeNodeConfig = pNodeManagerRoot->getNodeManagerByNamespace(nsTypeIdx)->getNodeManagerConfig();

        OpcUa::GenericObjectType* pObjectType;
        pObjectType = new OpcUa::GenericObjectType(
            UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType, nsTypeIdx),
            UaQualifiedName("BroadcastSearchAndIPSettingStateMachineType", nsTypeIdx),
            UaLocalizedText("", "BroadcastSearchAndIPSettingStateMachineType"),
            UaLocalizedText("", ""),
            OpcUa_False,
            &BroadcastSearchAndIPSettingStateMachineType::clearStaticMembers);
        addStatus = pTypeNodeConfig->addNodeAndReference(UaNodeId(OpcUaId_FiniteStateMachineType, nsSuperTypeIdx), pObjectType, OpcUaId_HasSubtype);
        UA_ASSERT(addStatus.isGood());
        // ------------------------------------------------------------------------
        // Method GetDiscoveredDevices
        // ------------------------------------------------------------------------
        s_pGetDiscoveredDevicesMethod = new OpcUa::BaseMethod(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_GetDiscoveredDevices, nsTypeIdx), "GetDiscoveredDevices", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace());
        s_pGetDiscoveredDevicesMethod->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pGetDiscoveredDevicesMethod, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());
        // ------------------------------------------------------------------------
        // Add OutputArguments
        // Create property
        pPropertyArg = new UaPropertyMethodArgument(
            UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_GetDiscoveredDevices_OutputArguments, nsTypeIdx),       // NodeId of the property
            OpcUa_AccessLevels_CurrentRead,          // Access level of the property
            1,                                      // Number of arguments
            UaPropertyMethodArgument::OUTARGUMENTS); // OUT arguments
        // Argument DiscoveredDevices
        arrayDimensions.create(1);
        arrayDimensions[0] = 0;
        pPropertyArg->setArgument(
            0,                      // Index of the argument
            "DiscoveredDevices",             // Name of the argument
            UaNodeId(MoxaClassBasedId_DiscoveredDeviceDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
            1,                     // Array rank of the argument
            arrayDimensions,
            UaLocalizedText("", "")); // Description
        // Set the ModellingRule to OutputArguments
        pPropertyArg->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        // Add property to method
        addStatus = pTypeNodeConfig->addNodeAndReference(s_pGetDiscoveredDevicesMethod, pPropertyArg, OpcUaId_HasProperty);
        UA_ASSERT(addStatus.isGood());

        // ------------------------------------------------------------------------
        // Method StartDeviceDiscovery
        // ------------------------------------------------------------------------
        s_pStartDeviceDiscoveryMethod = new OpcUa::BaseMethod(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_StartDeviceDiscovery, nsTypeIdx), "StartDeviceDiscovery", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace());
        s_pStartDeviceDiscoveryMethod->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pStartDeviceDiscoveryMethod, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());
        // ------------------------------------------------------------------------
        // Add InputArguments
        // Create property
        pPropertyArg = new UaPropertyMethodArgument(
            UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_StartDeviceDiscovery_InputArguments, nsTypeIdx),       // NodeId of the property
            OpcUa_AccessLevels_CurrentRead,         // Access level of the property
            1,                                      // Number of arguments
            UaPropertyMethodArgument::INARGUMENTS); // IN arguments
        // Argument Configuration
        arrayDimensions.clear();
        pPropertyArg->setArgument(
            0,                      // Index of the argument
            "Configuration",             // Name of the argument
            UaNodeId(MoxaClassBasedId_DeviceDiscoveryDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
            -1,                     // Array rank of the argument
            arrayDimensions,
            UaLocalizedText("", "")); // Description
        // Set the ModellingRule to InputArguments
        pPropertyArg->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        // Add property to method
        pTypeNodeConfig->addNodeAndReference(s_pStartDeviceDiscoveryMethod, pPropertyArg, OpcUaId_HasProperty);

        // ------------------------------------------------------------------------
        // Method StartInit
        // ------------------------------------------------------------------------
        s_pStartInitMethod = new OpcUa::BaseMethod(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_StartInit, nsTypeIdx), "StartInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace());
        s_pStartInitMethod->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pStartInitMethod, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());

        // ------------------------------------------------------------------------
        // Method StartIpConfigure
        // ------------------------------------------------------------------------
        s_pStartIpConfigureMethod = new OpcUa::BaseMethod(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_StartIpConfigure, nsTypeIdx), "StartIpConfigure", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace());
        s_pStartIpConfigureMethod->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pStartIpConfigureMethod, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());
        // ------------------------------------------------------------------------
        // Add InputArguments
        // Create property
        pPropertyArg = new UaPropertyMethodArgument(
            UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_StartIpConfigure_InputArguments, nsTypeIdx),       // NodeId of the property
            OpcUa_AccessLevels_CurrentRead,         // Access level of the property
            1,                                      // Number of arguments
            UaPropertyMethodArgument::INARGUMENTS); // IN arguments
        // Argument Configuration
        arrayDimensions.create(1);
        arrayDimensions[0] = 0;
        pPropertyArg->setArgument(
            0,                      // Index of the argument
            "Configuration",             // Name of the argument
            UaNodeId(MoxaClassBasedId_IpConfigureDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
            1,                     // Array rank of the argument
            arrayDimensions,
            UaLocalizedText("", "")); // Description
        // Set the ModellingRule to InputArguments
        pPropertyArg->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        // Add property to method
        pTypeNodeConfig->addNodeAndReference(s_pStartIpConfigureMethod, pPropertyArg, OpcUaId_HasProperty);

        // ------------------------------------------------------------------------
        // Method StartLinkSequenceDetect
        // ------------------------------------------------------------------------
        s_pStartLinkSequenceDetectMethod = new OpcUa::BaseMethod(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_StartLinkSequenceDetect, nsTypeIdx), "StartLinkSequenceDetect", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace());
        s_pStartLinkSequenceDetectMethod->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pStartLinkSequenceDetectMethod, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());

        // ------------------------------------------------------------------------
        // Method StartRetryConnection
        // ------------------------------------------------------------------------
        s_pStartRetryConnectionMethod = new OpcUa::BaseMethod(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_StartRetryConnection, nsTypeIdx), "StartRetryConnection", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace());
        s_pStartRetryConnectionMethod->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pStartRetryConnectionMethod, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());
        // ------------------------------------------------------------------------
        // Add InputArguments
        // Create property
        pPropertyArg = new UaPropertyMethodArgument(
            UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_StartRetryConnection_InputArguments, nsTypeIdx),       // NodeId of the property
            OpcUa_AccessLevels_CurrentRead,         // Access level of the property
            2,                                      // Number of arguments
            UaPropertyMethodArgument::INARGUMENTS); // IN arguments
        // Argument SNMP
        arrayDimensions.clear();
        pPropertyArg->setArgument(
            0,                      // Index of the argument
            "SNMP",             // Name of the argument
            UaNodeId(MoxaClassBasedId_SNMPDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
            -1,                     // Array rank of the argument
            arrayDimensions,
            UaLocalizedText("", "")); // Description
        // Argument RESTful
        pPropertyArg->setArgument(
            1,                      // Index of the argument
            "RESTful",             // Name of the argument
            UaNodeId(MoxaClassBasedId_RESTfulDataType, MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()),// Data type of the argument
            -1,                     // Array rank of the argument
            arrayDimensions,
            UaLocalizedText("", "")); // Description
        // Set the ModellingRule to InputArguments
        pPropertyArg->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        // Add property to method
        pTypeNodeConfig->addNodeAndReference(s_pStartRetryConnectionMethod, pPropertyArg, OpcUaId_HasProperty);

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscovered, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("DeviceDiscovered", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "DeviceDiscovered"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscovered_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pDeviceDiscovered = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDeviceDiscovered, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pDeviceDiscovered->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveredToInit, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("DeviceDiscoveredToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "DeviceDiscoveredToInit"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveredToInit_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pDeviceDiscoveredToInit = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDeviceDiscoveredToInit, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pDeviceDiscoveredToInit->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveredToLinkSequenceDetecting, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("DeviceDiscoveredToLinkSequenceDetecting", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "DeviceDiscoveredToLinkSequenceDetecting"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveredToLinkSequenceDetecting_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pDeviceDiscoveredToLinkSequenceDetecting = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDeviceDiscoveredToLinkSequenceDetecting, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pDeviceDiscoveredToLinkSequenceDetecting->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveredToRetryConnection, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("DeviceDiscoveredToRetryConnection", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "DeviceDiscoveredToRetryConnection"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveredToRetryConnection_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pDeviceDiscoveredToRetryConnection = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDeviceDiscoveredToRetryConnection, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pDeviceDiscoveredToRetryConnection->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscovering, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("DeviceDiscovering", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "DeviceDiscovering"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscovering_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pDeviceDiscovering = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDeviceDiscovering, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pDeviceDiscovering->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveringFailed, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("DeviceDiscoveringFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "DeviceDiscoveringFailed"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveringFailed_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pDeviceDiscoveringFailed = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDeviceDiscoveringFailed, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pDeviceDiscoveringFailed->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveringFailedToInit, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("DeviceDiscoveringFailedToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "DeviceDiscoveringFailedToInit"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveringFailedToInit_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pDeviceDiscoveringFailedToInit = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDeviceDiscoveringFailedToInit, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pDeviceDiscoveringFailedToInit->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveringToDeviceDiscovered, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("DeviceDiscoveringToDeviceDiscovered", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "DeviceDiscoveringToDeviceDiscovered"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveringToDeviceDiscovered_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pDeviceDiscoveringToDeviceDiscovered = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDeviceDiscoveringToDeviceDiscovered, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pDeviceDiscoveringToDeviceDiscovered->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveringToDeviceDiscoveringFailed, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("DeviceDiscoveringToDeviceDiscoveringFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "DeviceDiscoveringToDeviceDiscoveringFailed"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveringToDeviceDiscoveringFailed_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pDeviceDiscoveringToDeviceDiscoveringFailed = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDeviceDiscoveringToDeviceDiscoveringFailed, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pDeviceDiscoveringToDeviceDiscoveringFailed->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        // Object DiscoveredDevices
        s_pDiscoveredDevices = new OpcUa::FolderType(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DiscoveredDevices, nsTypeIdx), "DiscoveredDevices", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace(), pTypeNodeConfig);
        s_pDiscoveredDevices->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pDiscoveredDevices, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());
        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_Init, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("Init", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "Init"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_Init_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pInit = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pInit, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pInit->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_InitToDeviceDiscovering, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("InitToDeviceDiscovering", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "InitToDeviceDiscovering"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_InitToDeviceDiscovering_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pInitToDeviceDiscovering = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pInitToDeviceDiscovering, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pInitToDeviceDiscovering->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfigured, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("IpConfigured", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "IpConfigured"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfigured_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pIpConfigured = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pIpConfigured, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pIpConfigured->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguredToInit, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("IpConfiguredToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "IpConfiguredToInit"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguredToInit_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pIpConfiguredToInit = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pIpConfiguredToInit, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pIpConfiguredToInit->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguring, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("IpConfiguring", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "IpConfiguring"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguring_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pIpConfiguring = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pIpConfiguring, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pIpConfiguring->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringFailed, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("IpConfiguringFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "IpConfiguringFailed"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringFailed_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pIpConfiguringFailed = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pIpConfiguringFailed, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pIpConfiguringFailed->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringFailedToInit, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("IpConfiguringFailedToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "IpConfiguringFailedToInit"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringFailedToInit_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pIpConfiguringFailedToInit = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pIpConfiguringFailedToInit, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pIpConfiguringFailedToInit->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringFailedToIpConfiguring, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("IpConfiguringFailedToIpConfiguring", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "IpConfiguringFailedToIpConfiguring"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringFailedToIpConfiguring_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pIpConfiguringFailedToIpConfiguring = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pIpConfiguringFailedToIpConfiguring, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pIpConfiguringFailedToIpConfiguring->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringToIpConfigured, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("IpConfiguringToIpConfigured", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "IpConfiguringToIpConfigured"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringToIpConfigured_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pIpConfiguringToIpConfigured = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pIpConfiguringToIpConfigured, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pIpConfiguringToIpConfigured->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringToIpConfiguringFailed, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("IpConfiguringToIpConfiguringFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "IpConfiguringToIpConfiguringFailed"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringToIpConfiguringFailed_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pIpConfiguringToIpConfiguringFailed = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pIpConfiguringToIpConfiguringFailed, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pIpConfiguringToIpConfiguringFailed->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetected, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetected", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetected"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetected_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetected = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetected, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetected->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectedToInit, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetectedToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetectedToInit"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectedToInit_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetectedToInit = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetectedToInit, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetectedToInit->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectedToIpConfiguring, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetectedToIpConfiguring", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetectedToIpConfiguring"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectedToIpConfiguring_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetectedToIpConfiguring = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetectedToIpConfiguring, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetectedToIpConfiguring->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetecting, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetecting", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetecting"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetecting_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetecting = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetecting, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetecting->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingFailed, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetectingFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetectingFailed"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingFailed_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetectingFailed = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetectingFailed, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetectingFailed->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingFailedToInit, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetectingFailedToInit", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetectingFailedToInit"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingFailedToInit_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetectingFailedToInit = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetectingFailedToInit, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetectingFailedToInit->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingFailedToIpConfiguring, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetectingFailedToIpConfiguring", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetectingFailedToIpConfiguring"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingFailedToIpConfiguring_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetectingFailedToIpConfiguring = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetectingFailedToIpConfiguring, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetectingFailedToIpConfiguring->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingFailedToRetryConnection, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetectingFailedToRetryConnection", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetectingFailedToRetryConnection"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingFailedToRetryConnection_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetectingFailedToRetryConnection = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetectingFailedToRetryConnection, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetectingFailedToRetryConnection->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingToLinkSequenceDetected, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetectingToLinkSequenceDetected", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetectingToLinkSequenceDetected"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingToLinkSequenceDetected_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetectingToLinkSequenceDetected = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetectingToLinkSequenceDetected, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetectingToLinkSequenceDetected->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingToLinkSequenceDetectingFailed, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("LinkSequenceDetectingToLinkSequenceDetectingFailed", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "LinkSequenceDetectingToLinkSequenceDetectingFailed"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingToLinkSequenceDetectingFailed_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pLinkSequenceDetectingToLinkSequenceDetectingFailed = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pLinkSequenceDetectingToLinkSequenceDetectingFailed, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pLinkSequenceDetectingToLinkSequenceDetectingFailed->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_RetryConnection, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("RetryConnection", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "RetryConnection"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_RetryConnection_StateNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("StateNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "StateNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pRetryConnection = new OpcUa::StateType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pRetryConnection, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pRetryConnection->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }

        {
            std::list<UaBase::BaseNode*> lstBaseNodes;
            UaBase::Object *pChild = new UaBase::Object(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_RetryConnectionToDeviceDiscovered, nsTypeIdx));
            lstBaseNodes.push_back(pChild);
            pChild->setBrowseName(UaQualifiedName("RetryConnectionToDeviceDiscovered", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace()));
            pChild->setDisplayName(UaLocalizedText("", "RetryConnectionToDeviceDiscovered"));
            {
                UaBase::BaseNode *pParent = pChild;
                UaBase::BaseNode *pChild2;
                UaBase::FullReference reference;
                pChild2 = new UaBase::Variable(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_RetryConnectionToDeviceDiscovered_TransitionNumber, nsTypeIdx));
                lstBaseNodes.push_back(pChild2);
                pChild2->setBrowseName(UaQualifiedName("TransitionNumber", 0));
                pChild2->setDisplayName(UaLocalizedText("", "TransitionNumber"));
                ((UaBase::Variable*)pChild2)->setAccessLevel(1);
                ((UaBase::Variable*)pChild2)->setValueRank(-1);
                ((UaBase::Variable*)pChild2)->setDataTypeId(OpcUaId_UInt32);
                ((UaBase::Variable*)pChild2)->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
                ((UaBase::Variable*)pChild2)->setTypeDefinitionId(OpcUaId_PropertyType);
                reference.setReferenceTypeId(OpcUaId_HasProperty);
                reference.setSourceNode(pParent);
                reference.setTargetNode(pChild2);
                pParent->addFullReference(reference);
                pChild2->addFullReference(reference);
                pChild2->setParentNodeId(pParent->nodeId());
            }

            XmlUaNodeFactoryManager factory;

            s_pRetryConnectionToDeviceDiscovered = new OpcUa::TransitionType(pChild, &factory, pTypeNodeConfig, NULL);
            addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pRetryConnectionToDeviceDiscovered, OpcUaId_HasComponent);
            UA_ASSERT(addStatus.isGood());
            s_pRetryConnectionToDeviceDiscovered->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
            std::list<UaBase::BaseNode*>::iterator it = lstBaseNodes.begin();
            while (it != lstBaseNodes.end())
            {
                delete *it;
                it++;
            }
        }


        // Mandatory variable ErrorCode
        defaultValue.setUInt32(0);
        s_pErrorCode = new OpcUa::BaseDataVariableType(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_ErrorCode, nsTypeIdx), "ErrorCode", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace(), defaultValue, 3, pTypeNodeConfig);
        s_pErrorCode->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        s_pErrorCode->setValueRank(-1);
        addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pErrorCode, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());

        // Mandatory variable ErrorMessage
        defaultValue.setString("");
        s_pErrorMessage = new OpcUa::BaseDataVariableType(UaNodeId(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_ErrorMessage, nsTypeIdx), "ErrorMessage", MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace(), defaultValue, 3, pTypeNodeConfig);
        s_pErrorMessage->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        s_pErrorMessage->setValueRank(-1);
        addStatus = pTypeNodeConfig->addNodeAndReference(pObjectType, s_pErrorMessage, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());

    }
}

/** Clear the static members of the class
*/
void BroadcastSearchAndIPSettingStateMachineTypeBase::clearStaticMembers()
{
    s_typeNodesCreated = false;

    s_pDeviceDiscovered = NULL;
    s_pDeviceDiscoveredToInit = NULL;
    s_pDeviceDiscoveredToLinkSequenceDetecting = NULL;
    s_pDeviceDiscoveredToRetryConnection = NULL;
    s_pDeviceDiscovering = NULL;
    s_pDeviceDiscoveringFailed = NULL;
    s_pDeviceDiscoveringFailedToInit = NULL;
    s_pDeviceDiscoveringToDeviceDiscovered = NULL;
    s_pDeviceDiscoveringToDeviceDiscoveringFailed = NULL;
    s_pDiscoveredDevices = NULL;
    s_pInit = NULL;
    s_pInitToDeviceDiscovering = NULL;
    s_pIpConfigured = NULL;
    s_pIpConfiguredToInit = NULL;
    s_pIpConfiguring = NULL;
    s_pIpConfiguringFailed = NULL;
    s_pIpConfiguringFailedToInit = NULL;
    s_pIpConfiguringFailedToIpConfiguring = NULL;
    s_pIpConfiguringToIpConfigured = NULL;
    s_pIpConfiguringToIpConfiguringFailed = NULL;
    s_pLinkSequenceDetected = NULL;
    s_pLinkSequenceDetectedToInit = NULL;
    s_pLinkSequenceDetectedToIpConfiguring = NULL;
    s_pLinkSequenceDetecting = NULL;
    s_pLinkSequenceDetectingFailed = NULL;
    s_pLinkSequenceDetectingFailedToInit = NULL;
    s_pLinkSequenceDetectingFailedToIpConfiguring = NULL;
    s_pLinkSequenceDetectingFailedToRetryConnection = NULL;
    s_pLinkSequenceDetectingToLinkSequenceDetected = NULL;
    s_pLinkSequenceDetectingToLinkSequenceDetectingFailed = NULL;
    s_pRetryConnection = NULL;
    s_pRetryConnectionToDeviceDiscovered = NULL;
    s_pErrorCode = NULL;
    s_pErrorMessage = NULL;
    s_pGetDiscoveredDevicesMethod = NULL;
    s_pStartDeviceDiscoveryMethod = NULL;
    s_pStartInitMethod = NULL;
    s_pStartIpConfigureMethod = NULL;
    s_pStartLinkSequenceDetectMethod = NULL;
    s_pStartRetryConnectionMethod = NULL;
}

/** Returns the type definition NodeId for the BroadcastSearchAndIPSettingStateMachineType
*/
UaNodeId BroadcastSearchAndIPSettingStateMachineTypeBase::typeDefinitionId() const
{
    UaNodeId ret(MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType, NodeManagerMoxaClassBasedNS::getTypeNamespace());
    return ret;
}

/** Implementation of the MethodManager interface method beginCall
*/
UaStatus BroadcastSearchAndIPSettingStateMachineTypeBase::beginCall(
    MethodManagerCallback* pCallback,
    const ServiceContext&  serviceContext,
    OpcUa_UInt32           callbackHandle,
    MethodHandle*          pMethodHandle,
    const UaVariantArray&  inputArguments)
{
    UaStatus            ret;

    OpcUa::MethodCallJob* pCallJob = new OpcUa::MethodCallJob;
    pCallJob->initialize(this, pCallback, serviceContext, callbackHandle, pMethodHandle, inputArguments);
    ret = NodeManagerRoot::CreateRootNodeManager()->pServerManager()->getThreadPool()->addJob(pCallJob);
    if ( ret.isBad() )
    {
        delete pCallJob;
    }

    return ret;
}

/** Synchronous version of the MethodManager method call executed in a worker thread
*/
UaStatus BroadcastSearchAndIPSettingStateMachineTypeBase::call(
    const ServiceContext&  serviceContext,
    MethodHandle*          pMethodHandle,
    const UaVariantArray&  inputArguments,
    UaVariantArray&        outputArguments,
    UaStatusCodeArray&     inputArgumentResults,
    UaDiagnosticInfos&     inputArgumentDiag)
{
    UaStatus            ret;
    MethodHandleUaNode* pMethodHandleUaNode = (MethodHandleUaNode*)pMethodHandle;
    UaMethod*           pMethod             = NULL;

    if (pMethodHandleUaNode)
    {
        pMethod = pMethodHandleUaNode->pUaMethod();

        if (pMethod)
        {
            if ( ( (m_pGetDiscoveredDevicesMethod != NULL) && (pMethod->nodeId() == m_pGetDiscoveredDevicesMethod->nodeId()) )
                 || ( (s_pGetDiscoveredDevicesMethod != NULL) && (pMethod->nodeId() == s_pGetDiscoveredDevicesMethod->nodeId()) ) )
            {
                if ( inputArguments.length() > 0 )
                {
                    ret = OpcUa_BadTooManyArguments;
                }
                else
                {
                    MoxaClassBased::DiscoveredDeviceDataTypes DiscoveredDevices;
                    UaVariant value;
                    UaStatus tmpRet;

                    ret = this->GetDiscoveredDevices(serviceContext, DiscoveredDevices);
                    if ( ret.isNotBad() )
                    {
                        outputArguments.create(1);
                        DiscoveredDevices.toVariant(outputArguments[ 0 ], OpcUa_True);
                    }
                }

            }
            else if ( ( (m_pStartDeviceDiscoveryMethod != NULL) && (pMethod->nodeId() == m_pStartDeviceDiscoveryMethod->nodeId()) )
                      || ( (s_pStartDeviceDiscoveryMethod != NULL) && (pMethod->nodeId() == s_pStartDeviceDiscoveryMethod->nodeId()) ) )
            {
                if ( inputArguments.length() < 1 )
                {
                    ret = OpcUa_BadArgumentsMissing;
                }
                else if ( inputArguments.length() > 1 )
                {
                    ret = OpcUa_BadTooManyArguments;
                }
                else
                {
                    inputArgumentResults.create(1);

                    UaVariant value;
                    UaStatus tmpRet;

                    MoxaClassBased::DeviceDiscoveryDataType Configuration;
                    value = inputArguments[ 0 ];
                    UaExtensionObject extConfiguration;
                    value.toExtensionObject(extConfiguration);
                    tmpRet = Configuration.setDeviceDiscoveryDataType(extConfiguration, OpcUa_True);
                    inputArgumentResults[ 0 ] = tmpRet.statusCode();
                    if (tmpRet.isNotGood()) {ret = tmpRet;}

                    if ( ret.isGood() )
                    {
                        ret = this->StartDeviceDiscovery(serviceContext, Configuration);
                    }
                }

            }
            else if ( ( (m_pStartInitMethod != NULL) && (pMethod->nodeId() == m_pStartInitMethod->nodeId()) )
                      || ( (s_pStartInitMethod != NULL) && (pMethod->nodeId() == s_pStartInitMethod->nodeId()) ) )
            {
                if ( inputArguments.length() > 0 )
                {
                    ret = OpcUa_BadTooManyArguments;
                }
                else
                {
                    ret = this->StartInit(serviceContext);
                }

            }
            else if ( ( (m_pStartIpConfigureMethod != NULL) && (pMethod->nodeId() == m_pStartIpConfigureMethod->nodeId()) )
                      || ( (s_pStartIpConfigureMethod != NULL) && (pMethod->nodeId() == s_pStartIpConfigureMethod->nodeId()) ) )
            {
                if ( inputArguments.length() < 1 )
                {
                    ret = OpcUa_BadArgumentsMissing;
                }
                else if ( inputArguments.length() > 1 )
                {
                    ret = OpcUa_BadTooManyArguments;
                }
                else
                {
                    inputArgumentResults.create(1);

                    UaVariant value;
                    UaStatus tmpRet;

                    MoxaClassBased::IpConfigureDataTypes Configuration;
                    tmpRet = Configuration.setIpConfigureDataTypes(inputArguments[ 0 ]);
                    inputArgumentResults[ 0 ] = tmpRet.statusCode();
                    if (tmpRet.isNotGood()) {ret = tmpRet;}

                    if ( ret.isGood() )
                    {
                        ret = this->StartIpConfigure(serviceContext, Configuration);
                    }
                }

            }
            else if ( ( (m_pStartLinkSequenceDetectMethod != NULL) && (pMethod->nodeId() == m_pStartLinkSequenceDetectMethod->nodeId()) )
                      || ( (s_pStartLinkSequenceDetectMethod != NULL) && (pMethod->nodeId() == s_pStartLinkSequenceDetectMethod->nodeId()) ) )
            {
                if ( inputArguments.length() > 0 )
                {
                    ret = OpcUa_BadTooManyArguments;
                }
                else
                {
                    ret = this->StartLinkSequenceDetect(serviceContext);
                }

            }
            else if ( ( (m_pStartRetryConnectionMethod != NULL) && (pMethod->nodeId() == m_pStartRetryConnectionMethod->nodeId()) )
                      || ( (s_pStartRetryConnectionMethod != NULL) && (pMethod->nodeId() == s_pStartRetryConnectionMethod->nodeId()) ) )
            {
                if ( inputArguments.length() < 2 )
                {
                    ret = OpcUa_BadArgumentsMissing;
                }
                else if ( inputArguments.length() > 2 )
                {
                    ret = OpcUa_BadTooManyArguments;
                }
                else
                {
                    inputArgumentResults.create(2);

                    UaVariant value;
                    UaStatus tmpRet;

                    MoxaClassBased::SNMPDataType SNMP;
                    value = inputArguments[ 0 ];
                    UaExtensionObject extSNMP;
                    value.toExtensionObject(extSNMP);
                    tmpRet = SNMP.setSNMPDataType(extSNMP, OpcUa_True);
                    inputArgumentResults[ 0 ] = tmpRet.statusCode();
                    if (tmpRet.isNotGood()) {ret = tmpRet;}

                    MoxaClassBased::RESTfulDataType RESTful;
                    value = inputArguments[ 1 ];
                    UaExtensionObject extRESTful;
                    value.toExtensionObject(extRESTful);
                    tmpRet = RESTful.setRESTfulDataType(extRESTful, OpcUa_True);
                    inputArgumentResults[ 1 ] = tmpRet.statusCode();
                    if (tmpRet.isNotGood()) {ret = tmpRet;}

                    if ( ret.isGood() )
                    {
                        ret = this->StartRetryConnection(serviceContext, SNMP, RESTful);
                    }
                }

            }
            else
            {
                return FiniteStateMachineType::call(serviceContext, pMethodHandle, inputArguments, outputArguments, inputArgumentResults, inputArgumentDiag);
            }
        }
        else
        {
            assert(false);
            ret = OpcUa_BadInvalidArgument;
        }
    }
    else
    {
        assert(false);
        ret = OpcUa_BadInvalidArgument;
    }

    return ret;
}

/**
 *  Sets the ErrorCode value
 */
void BroadcastSearchAndIPSettingStateMachineTypeBase::setErrorCode(OpcUa_UInt32 ErrorCode)
{
    UaVariant value;
    value.setUInt32(ErrorCode);
    UaDataValue dataValue;
    dataValue.setValue(value, OpcUa_True, OpcUa_True);
    m_pErrorCode->setValue(NULL, dataValue, OpcUa_False);
}

/**
 *  Returns the value of ErrorCode
 */
OpcUa_UInt32 BroadcastSearchAndIPSettingStateMachineTypeBase::getErrorCode() const
{
    UaVariant defaultValue;
    OpcUa_UInt32 ret = 0;
    UaDataValue dataValue(m_pErrorCode->value(NULL));
    defaultValue = *dataValue.value();
    defaultValue.toUInt32(ret);
    return ret;
}

/**
 *  Sets the ErrorMessage value
 */
void BroadcastSearchAndIPSettingStateMachineTypeBase::setErrorMessage(const UaString& ErrorMessage)
{
    UaVariant value;
    value.setString(ErrorMessage);
    UaDataValue dataValue;
    dataValue.setValue(value, OpcUa_True, OpcUa_True);
    m_pErrorMessage->setValue(NULL, dataValue, OpcUa_False);
}

/**
 *  Returns the value of ErrorMessage
 */
UaString BroadcastSearchAndIPSettingStateMachineTypeBase::getErrorMessage() const
{
    UaVariant defaultValue;
    UaString ret;
    UaDataValue dataValue(m_pErrorMessage->value(NULL));
    defaultValue = *dataValue.value();
    ret = defaultValue.toString();
    return ret;
}

/** Returns the DeviceDiscovered node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscovered()
{
    return m_pDeviceDiscovered;
}

/** Returns the DeviceDiscovered node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscovered() const
{
    return m_pDeviceDiscovered;
}

/** Returns the DeviceDiscoveredToInit node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveredToInit()
{
    return m_pDeviceDiscoveredToInit;
}

/** Returns the DeviceDiscoveredToInit node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveredToInit() const
{
    return m_pDeviceDiscoveredToInit;
}

/** Returns the DeviceDiscoveredToLinkSequenceDetecting node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveredToLinkSequenceDetecting()
{
    return m_pDeviceDiscoveredToLinkSequenceDetecting;
}

/** Returns the DeviceDiscoveredToLinkSequenceDetecting node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveredToLinkSequenceDetecting() const
{
    return m_pDeviceDiscoveredToLinkSequenceDetecting;
}

/** Returns the DeviceDiscoveredToRetryConnection node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveredToRetryConnection()
{
    return m_pDeviceDiscoveredToRetryConnection;
}

/** Returns the DeviceDiscoveredToRetryConnection node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveredToRetryConnection() const
{
    return m_pDeviceDiscoveredToRetryConnection;
}

/** Returns the DeviceDiscovering node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscovering()
{
    return m_pDeviceDiscovering;
}

/** Returns the DeviceDiscovering node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscovering() const
{
    return m_pDeviceDiscovering;
}

/** Returns the DeviceDiscoveringFailed node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveringFailed()
{
    return m_pDeviceDiscoveringFailed;
}

/** Returns the DeviceDiscoveringFailed node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveringFailed() const
{
    return m_pDeviceDiscoveringFailed;
}

/** Returns the DeviceDiscoveringFailedToInit node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveringFailedToInit()
{
    return m_pDeviceDiscoveringFailedToInit;
}

/** Returns the DeviceDiscoveringFailedToInit node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveringFailedToInit() const
{
    return m_pDeviceDiscoveringFailedToInit;
}

/** Returns the DeviceDiscoveringToDeviceDiscovered node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveringToDeviceDiscovered()
{
    return m_pDeviceDiscoveringToDeviceDiscovered;
}

/** Returns the DeviceDiscoveringToDeviceDiscovered node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveringToDeviceDiscovered() const
{
    return m_pDeviceDiscoveringToDeviceDiscovered;
}

/** Returns the DeviceDiscoveringToDeviceDiscoveringFailed node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveringToDeviceDiscoveringFailed()
{
    return m_pDeviceDiscoveringToDeviceDiscoveringFailed;
}

/** Returns the DeviceDiscoveringToDeviceDiscoveringFailed node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDeviceDiscoveringToDeviceDiscoveringFailed() const
{
    return m_pDeviceDiscoveringToDeviceDiscoveringFailed;
}

/** Returns the DiscoveredDevices node.
 */
OpcUa::FolderType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDiscoveredDevices()
{
    return m_pDiscoveredDevices;
}

/** Returns the DiscoveredDevices node.
 */
const OpcUa::FolderType* BroadcastSearchAndIPSettingStateMachineTypeBase::getDiscoveredDevices() const
{
    return m_pDiscoveredDevices;
}

/** Returns the ErrorCode node.
 */
OpcUa::BaseDataVariableType* BroadcastSearchAndIPSettingStateMachineTypeBase::getErrorCodeNode()
{
    return m_pErrorCode;
}

/** Returns the ErrorCode node.
 */
const OpcUa::BaseDataVariableType* BroadcastSearchAndIPSettingStateMachineTypeBase::getErrorCodeNode() const
{
    return m_pErrorCode;
}

/** Returns the ErrorMessage node.
 */
OpcUa::BaseDataVariableType* BroadcastSearchAndIPSettingStateMachineTypeBase::getErrorMessageNode()
{
    return m_pErrorMessage;
}

/** Returns the ErrorMessage node.
 */
const OpcUa::BaseDataVariableType* BroadcastSearchAndIPSettingStateMachineTypeBase::getErrorMessageNode() const
{
    return m_pErrorMessage;
}

/** Returns the Init node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getInit()
{
    return m_pInit;
}

/** Returns the Init node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getInit() const
{
    return m_pInit;
}

/** Returns the InitToDeviceDiscovering node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getInitToDeviceDiscovering()
{
    return m_pInitToDeviceDiscovering;
}

/** Returns the InitToDeviceDiscovering node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getInitToDeviceDiscovering() const
{
    return m_pInitToDeviceDiscovering;
}

/** Returns the IpConfigured node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfigured()
{
    return m_pIpConfigured;
}

/** Returns the IpConfigured node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfigured() const
{
    return m_pIpConfigured;
}

/** Returns the IpConfiguredToInit node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguredToInit()
{
    return m_pIpConfiguredToInit;
}

/** Returns the IpConfiguredToInit node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguredToInit() const
{
    return m_pIpConfiguredToInit;
}

/** Returns the IpConfiguring node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguring()
{
    return m_pIpConfiguring;
}

/** Returns the IpConfiguring node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguring() const
{
    return m_pIpConfiguring;
}

/** Returns the IpConfiguringFailed node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringFailed()
{
    return m_pIpConfiguringFailed;
}

/** Returns the IpConfiguringFailed node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringFailed() const
{
    return m_pIpConfiguringFailed;
}

/** Returns the IpConfiguringFailedToInit node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringFailedToInit()
{
    return m_pIpConfiguringFailedToInit;
}

/** Returns the IpConfiguringFailedToInit node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringFailedToInit() const
{
    return m_pIpConfiguringFailedToInit;
}

/** Returns the IpConfiguringFailedToIpConfiguring node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringFailedToIpConfiguring()
{
    return m_pIpConfiguringFailedToIpConfiguring;
}

/** Returns the IpConfiguringFailedToIpConfiguring node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringFailedToIpConfiguring() const
{
    return m_pIpConfiguringFailedToIpConfiguring;
}

/** Returns the IpConfiguringToIpConfigured node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringToIpConfigured()
{
    return m_pIpConfiguringToIpConfigured;
}

/** Returns the IpConfiguringToIpConfigured node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringToIpConfigured() const
{
    return m_pIpConfiguringToIpConfigured;
}

/** Returns the IpConfiguringToIpConfiguringFailed node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringToIpConfiguringFailed()
{
    return m_pIpConfiguringToIpConfiguringFailed;
}

/** Returns the IpConfiguringToIpConfiguringFailed node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getIpConfiguringToIpConfiguringFailed() const
{
    return m_pIpConfiguringToIpConfiguringFailed;
}

/** Returns the LinkSequenceDetected node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetected()
{
    return m_pLinkSequenceDetected;
}

/** Returns the LinkSequenceDetected node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetected() const
{
    return m_pLinkSequenceDetected;
}

/** Returns the LinkSequenceDetectedToInit node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectedToInit()
{
    return m_pLinkSequenceDetectedToInit;
}

/** Returns the LinkSequenceDetectedToInit node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectedToInit() const
{
    return m_pLinkSequenceDetectedToInit;
}

/** Returns the LinkSequenceDetectedToIpConfiguring node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectedToIpConfiguring()
{
    return m_pLinkSequenceDetectedToIpConfiguring;
}

/** Returns the LinkSequenceDetectedToIpConfiguring node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectedToIpConfiguring() const
{
    return m_pLinkSequenceDetectedToIpConfiguring;
}

/** Returns the LinkSequenceDetecting node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetecting()
{
    return m_pLinkSequenceDetecting;
}

/** Returns the LinkSequenceDetecting node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetecting() const
{
    return m_pLinkSequenceDetecting;
}

/** Returns the LinkSequenceDetectingFailed node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingFailed()
{
    return m_pLinkSequenceDetectingFailed;
}

/** Returns the LinkSequenceDetectingFailed node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingFailed() const
{
    return m_pLinkSequenceDetectingFailed;
}

/** Returns the LinkSequenceDetectingFailedToInit node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingFailedToInit()
{
    return m_pLinkSequenceDetectingFailedToInit;
}

/** Returns the LinkSequenceDetectingFailedToInit node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingFailedToInit() const
{
    return m_pLinkSequenceDetectingFailedToInit;
}

/** Returns the LinkSequenceDetectingFailedToIpConfiguring node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingFailedToIpConfiguring()
{
    return m_pLinkSequenceDetectingFailedToIpConfiguring;
}

/** Returns the LinkSequenceDetectingFailedToIpConfiguring node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingFailedToIpConfiguring() const
{
    return m_pLinkSequenceDetectingFailedToIpConfiguring;
}

/** Returns the LinkSequenceDetectingFailedToRetryConnection node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingFailedToRetryConnection()
{
    return m_pLinkSequenceDetectingFailedToRetryConnection;
}

/** Returns the LinkSequenceDetectingFailedToRetryConnection node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingFailedToRetryConnection() const
{
    return m_pLinkSequenceDetectingFailedToRetryConnection;
}

/** Returns the LinkSequenceDetectingToLinkSequenceDetected node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingToLinkSequenceDetected()
{
    return m_pLinkSequenceDetectingToLinkSequenceDetected;
}

/** Returns the LinkSequenceDetectingToLinkSequenceDetected node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingToLinkSequenceDetected() const
{
    return m_pLinkSequenceDetectingToLinkSequenceDetected;
}

/** Returns the LinkSequenceDetectingToLinkSequenceDetectingFailed node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingToLinkSequenceDetectingFailed()
{
    return m_pLinkSequenceDetectingToLinkSequenceDetectingFailed;
}

/** Returns the LinkSequenceDetectingToLinkSequenceDetectingFailed node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getLinkSequenceDetectingToLinkSequenceDetectingFailed() const
{
    return m_pLinkSequenceDetectingToLinkSequenceDetectingFailed;
}

/** Returns the RetryConnection node.
 */
OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getRetryConnection()
{
    return m_pRetryConnection;
}

/** Returns the RetryConnection node.
 */
const OpcUa::StateType* BroadcastSearchAndIPSettingStateMachineTypeBase::getRetryConnection() const
{
    return m_pRetryConnection;
}

/** Returns the RetryConnectionToDeviceDiscovered node.
 */
OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getRetryConnectionToDeviceDiscovered()
{
    return m_pRetryConnectionToDeviceDiscovered;
}

/** Returns the RetryConnectionToDeviceDiscovered node.
 */
const OpcUa::TransitionType* BroadcastSearchAndIPSettingStateMachineTypeBase::getRetryConnectionToDeviceDiscovered() const
{
    return m_pRetryConnectionToDeviceDiscovered;
}

/** Returns the GetDiscoveredDevices node.
  */
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getGetDiscoveredDevices()
{
    return m_pGetDiscoveredDevicesMethod;
}

/** Returns the GetDiscoveredDevices node.
  */
const OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getGetDiscoveredDevices() const
{
    return m_pGetDiscoveredDevicesMethod;
}
/** Returns the StartDeviceDiscovery node.
  */
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartDeviceDiscovery()
{
    return m_pStartDeviceDiscoveryMethod;
}

/** Returns the StartDeviceDiscovery node.
  */
const OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartDeviceDiscovery() const
{
    return m_pStartDeviceDiscoveryMethod;
}
/** Returns the StartInit node.
  */
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartInit()
{
    return m_pStartInitMethod;
}

/** Returns the StartInit node.
  */
const OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartInit() const
{
    return m_pStartInitMethod;
}
/** Returns the StartIpConfigure node.
  */
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartIpConfigure()
{
    return m_pStartIpConfigureMethod;
}

/** Returns the StartIpConfigure node.
  */
const OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartIpConfigure() const
{
    return m_pStartIpConfigureMethod;
}
/** Returns the StartLinkSequenceDetect node.
  */
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartLinkSequenceDetect()
{
    return m_pStartLinkSequenceDetectMethod;
}

/** Returns the StartLinkSequenceDetect node.
  */
const OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartLinkSequenceDetect() const
{
    return m_pStartLinkSequenceDetectMethod;
}
/** Returns the StartRetryConnection node.
  */
OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartRetryConnection()
{
    return m_pStartRetryConnectionMethod;
}

/** Returns the StartRetryConnection node.
  */
const OpcUa::BaseMethod* BroadcastSearchAndIPSettingStateMachineTypeBase::getStartRetryConnection() const
{
    return m_pStartRetryConnectionMethod;
}

/** Uses the NodeAccessInfo of pOther and its children. */
void BroadcastSearchAndIPSettingStateMachineTypeBase::useAccessInfoFromInstance(BroadcastSearchAndIPSettingStateMachineTypeBase *pOther)
{
    OpcUa::FiniteStateMachineType::useAccessInfoFromInstance(pOther);

    // children
    m_pDeviceDiscovered->useAccessInfoFromInstance(pOther->m_pDeviceDiscovered);
    m_pDeviceDiscoveredToInit->useAccessInfoFromInstance(pOther->m_pDeviceDiscoveredToInit);
    m_pDeviceDiscoveredToLinkSequenceDetecting->useAccessInfoFromInstance(pOther->m_pDeviceDiscoveredToLinkSequenceDetecting);
    m_pDeviceDiscoveredToRetryConnection->useAccessInfoFromInstance(pOther->m_pDeviceDiscoveredToRetryConnection);
    m_pDeviceDiscovering->useAccessInfoFromInstance(pOther->m_pDeviceDiscovering);
    m_pDeviceDiscoveringFailed->useAccessInfoFromInstance(pOther->m_pDeviceDiscoveringFailed);
    m_pDeviceDiscoveringFailedToInit->useAccessInfoFromInstance(pOther->m_pDeviceDiscoveringFailedToInit);
    m_pDeviceDiscoveringToDeviceDiscovered->useAccessInfoFromInstance(pOther->m_pDeviceDiscoveringToDeviceDiscovered);
    m_pDeviceDiscoveringToDeviceDiscoveringFailed->useAccessInfoFromInstance(pOther->m_pDeviceDiscoveringToDeviceDiscoveringFailed);
    m_pDiscoveredDevices->useAccessInfoFromInstance(pOther->m_pDiscoveredDevices);
    m_pInit->useAccessInfoFromInstance(pOther->m_pInit);
    m_pInitToDeviceDiscovering->useAccessInfoFromInstance(pOther->m_pInitToDeviceDiscovering);
    m_pIpConfigured->useAccessInfoFromInstance(pOther->m_pIpConfigured);
    m_pIpConfiguredToInit->useAccessInfoFromInstance(pOther->m_pIpConfiguredToInit);
    m_pIpConfiguring->useAccessInfoFromInstance(pOther->m_pIpConfiguring);
    m_pIpConfiguringFailed->useAccessInfoFromInstance(pOther->m_pIpConfiguringFailed);
    m_pIpConfiguringFailedToInit->useAccessInfoFromInstance(pOther->m_pIpConfiguringFailedToInit);
    m_pIpConfiguringFailedToIpConfiguring->useAccessInfoFromInstance(pOther->m_pIpConfiguringFailedToIpConfiguring);
    m_pIpConfiguringToIpConfigured->useAccessInfoFromInstance(pOther->m_pIpConfiguringToIpConfigured);
    m_pIpConfiguringToIpConfiguringFailed->useAccessInfoFromInstance(pOther->m_pIpConfiguringToIpConfiguringFailed);
    m_pLinkSequenceDetected->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetected);
    m_pLinkSequenceDetectedToInit->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetectedToInit);
    m_pLinkSequenceDetectedToIpConfiguring->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetectedToIpConfiguring);
    m_pLinkSequenceDetecting->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetecting);
    m_pLinkSequenceDetectingFailed->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetectingFailed);
    m_pLinkSequenceDetectingFailedToInit->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetectingFailedToInit);
    m_pLinkSequenceDetectingFailedToIpConfiguring->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetectingFailedToIpConfiguring);
    m_pLinkSequenceDetectingFailedToRetryConnection->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetectingFailedToRetryConnection);
    m_pLinkSequenceDetectingToLinkSequenceDetected->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetectingToLinkSequenceDetected);
    m_pLinkSequenceDetectingToLinkSequenceDetectingFailed->useAccessInfoFromInstance(pOther->m_pLinkSequenceDetectingToLinkSequenceDetectingFailed);
    m_pRetryConnection->useAccessInfoFromInstance(pOther->m_pRetryConnection);
    m_pRetryConnectionToDeviceDiscovered->useAccessInfoFromInstance(pOther->m_pRetryConnectionToDeviceDiscovered);
    m_pErrorCode->useAccessInfoFromInstance(pOther->m_pErrorCode);
    m_pErrorMessage->useAccessInfoFromInstance(pOther->m_pErrorMessage);
    m_pGetDiscoveredDevicesMethod->useAccessInfoFrom(pOther->m_pGetDiscoveredDevicesMethod);
    m_pStartDeviceDiscoveryMethod->useAccessInfoFrom(pOther->m_pStartDeviceDiscoveryMethod);
    m_pStartInitMethod->useAccessInfoFrom(pOther->m_pStartInitMethod);
    m_pStartIpConfigureMethod->useAccessInfoFrom(pOther->m_pStartIpConfigureMethod);
    m_pStartLinkSequenceDetectMethod->useAccessInfoFrom(pOther->m_pStartLinkSequenceDetectMethod);
    m_pStartRetryConnectionMethod->useAccessInfoFrom(pOther->m_pStartRetryConnectionMethod);
}

/** Set the NodeAccessInfo for this node and all of its children. */
void BroadcastSearchAndIPSettingStateMachineTypeBase::setAccessInfoWithChildren(NodeAccessInfo* pNodeAccessInfo)
{
    OpcUa::FiniteStateMachineType::setAccessInfoWithChildren(pNodeAccessInfo);

    // children
    m_pDeviceDiscovered->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pDeviceDiscoveredToInit->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pDeviceDiscoveredToLinkSequenceDetecting->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pDeviceDiscoveredToRetryConnection->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pDeviceDiscovering->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pDeviceDiscoveringFailed->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pDeviceDiscoveringFailedToInit->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pDeviceDiscoveringToDeviceDiscovered->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pDeviceDiscoveringToDeviceDiscoveringFailed->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pDiscoveredDevices->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pInit->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pInitToDeviceDiscovering->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pIpConfigured->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pIpConfiguredToInit->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pIpConfiguring->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pIpConfiguringFailed->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pIpConfiguringFailedToInit->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pIpConfiguringFailedToIpConfiguring->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pIpConfiguringToIpConfigured->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pIpConfiguringToIpConfiguringFailed->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetected->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetectedToInit->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetectedToIpConfiguring->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetecting->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetectingFailed->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetectingFailedToInit->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetectingFailedToIpConfiguring->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetectingFailedToRetryConnection->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetectingToLinkSequenceDetected->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pLinkSequenceDetectingToLinkSequenceDetectingFailed->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pRetryConnection->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pRetryConnectionToDeviceDiscovered->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pErrorCode->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pErrorMessage->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pGetDiscoveredDevicesMethod->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pStartDeviceDiscoveryMethod->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pStartInitMethod->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pStartIpConfigureMethod->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pStartLinkSequenceDetectMethod->setAccessInfoWithChildren(pNodeAccessInfo);
    m_pStartRetryConnectionMethod->setAccessInfoWithChildren(pNodeAccessInfo);
}


UaStatus BroadcastSearchAndIPSettingStateMachineTypeBase::setBroadcastSearchAndIPSettingState(BroadcastSearchAndIPSettingStateMachineTypeBase::BroadcastSearchAndIPSettingState state)
{
    UaNodeId currentTransitionId;
    UaLocalizedText ltTransition;
    BroadcastSearchAndIPSettingState currentState = getBroadcastSearchAndIPSettingState();
    switch (currentState)
    {
    case DeviceDiscovered:
        break;
    case DeviceDiscovering:
        break;
    case DeviceDiscoveringFailed:
        break;
    case Init:
        break;
    case IpConfigured:
        break;
    case IpConfiguring:
        break;
    case IpConfiguringFailed:
        break;
    case LinkSequenceDetected:
        break;
    case LinkSequenceDetecting:
        break;
    case LinkSequenceDetectingFailed:
        break;
    case RetryConnection:
        break;
    }
    return OpcUa_Bad;
}
BroadcastSearchAndIPSettingStateMachineTypeBase::BroadcastSearchAndIPSettingState BroadcastSearchAndIPSettingStateMachineTypeBase::getBroadcastSearchAndIPSettingState()
{
    BroadcastSearchAndIPSettingState ret = DeviceDiscovered;

    UaNodeId state(getCurrentStateNode()->getIdNodeId());
    OpcUa_UInt16 nsTypeIdx = MoxaClassBased::NodeManagerMoxaClassBasedNS::getTypeNamespace();

    if (state.identifierType() == OpcUa_IdentifierType_Numeric && state.namespaceIndex() == nsTypeIdx)
    {
        switch (state.identifierNumeric())
        {
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscovered:
            ret = DeviceDiscovered;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscovering:
            ret = DeviceDiscovering;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_DeviceDiscoveringFailed:
            ret = DeviceDiscoveringFailed;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_Init:
            ret = Init;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfigured:
            ret = IpConfigured;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguring:
            ret = IpConfiguring;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_IpConfiguringFailed:
            ret = IpConfiguringFailed;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetected:
            ret = LinkSequenceDetected;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetecting:
            ret = LinkSequenceDetecting;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_LinkSequenceDetectingFailed:
            ret = LinkSequenceDetectingFailed;
            break;
        case MoxaClassBasedId_BroadcastSearchAndIPSettingStateMachineType_RetryConnection:
            ret = RetryConnection;
            break;
        default:
            break;
        }
    }
    return ret;
}
} // End namespace for the UA information model http://www.moxa.com/auto-configuration-tool-class-based-model/


