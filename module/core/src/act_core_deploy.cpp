#ifdef _WIN32
#include <windows.h>
#define SLEEP_MS(ms) Sleep(ms)
#else
#include <unistd.h>  // for sleep
#define SLEEP_MS(ms) sleep(ms / 1000)
#endif

#include <QSet>
#include <thread>

#include "act_broadcast_search.hpp"
#include "act_core.hpp"
#include "act_deploy.hpp"

namespace act {
namespace core {

ACT_STATUS GetDeployDevicesFromProject(ActProject &project, ActDeployDeviceList &deploy_device_list) {
  ACT_STATUS_INIT();

  QList<ActDeployDevice> deploy_devices;

  for (auto device : project.GetDevices()) {
    if (!device.CheckCanDeploy()) {
      continue;
    }

    ActDeployDevice deploy_device(device);
    quint32 ip_num;
    device.GetIpv4().GetIpAddressNumber(ip_num);
    deploy_device.address_number_ = ip_num;

    deploy_device.SetModelName(device.GetDeviceProperty().GetModelName());
    deploy_device.SetFirmwareVersion(device.GetFirmwareVersion());
    deploy_device.SetMacAddress(device.GetMacAddress());
    deploy_device.SetSerialNumber(device.GetDeviceInfo().GetSerialNumber());
    deploy_device.SetLocation(device.GetDeviceInfo().GetLocation());
    deploy_devices.append(deploy_device);
  }

  // Sort by IP num (from small to large)
  std::sort(deploy_devices.begin(), deploy_devices.end());

  deploy_device_list.SetDeviceList(deploy_devices);

  return ACT_STATUS_SUCCESS;
}

ACT_STATUS ActCore::GetDesignBaselineDeployDevices(qint64 &project_id, const qint64 &design_baseline_id,
                                                   ActDeployDeviceList &deploy_device_list) {
  ACT_STATUS_INIT();

  QList<ActDeployDevice> deploy_devices;

  // Get project by id
  ActProject baseline_project;
  act_status = this->GetDesignBaselineProject(project_id, design_baseline_id, baseline_project);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << QString("Get the DesignBaseline project failed with project_id: %1 & design_baseline_id: %2")
                       .arg(project_id)
                       .arg(design_baseline_id);
    return act_status;
  }

  return GetDeployDevicesFromProject(baseline_project, deploy_device_list);
}

ACT_STATUS ActCore::GetProjectDeployDevices(qint64 &project_id, ActDeployDeviceList &deploy_device_list) {
  ACT_STATUS_INIT();

  QList<ActDeployDevice> deploy_devices;

  // Get project by id
  ActProject project;
  act_status = this->GetProject(project_id, project);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << "Get project failed with project id:" << project_id;
    return act_status;
  }

  return GetDeployDevicesFromProject(project, deploy_device_list);
}

bool CheckDeviceInDeviceConfig(const ActDeviceConfig &device_config, const qint64 device_id) {
  // MappingDeviceIpSettingTables
  if (device_config.GetMappingDeviceIpSettingTables().contains(device_id)) {
    return true;
  }

  // NetworkSettingTables
  if (device_config.GetNetworkSettingTables().contains(device_id)) {
    return true;
  }

  // PortSettingTables
  if (device_config.GetPortSettingTables().contains(device_id)) {
    return true;
  }

  // VlanTables
  if (device_config.GetVlanTables().contains(device_id)) {
    return true;
  }

  // UnicastStaticForwardTables
  if (device_config.GetUnicastStaticForwardTables().contains(device_id)) {
    return true;
  }

  // MulticastStaticForwardTables
  if (device_config.GetMulticastStaticForwardTables().contains(device_id)) {
    return true;
  }

  // PortDefaultPCPTables
  if (device_config.GetPortDefaultPCPTables().contains(device_id)) {
    return true;
  }

  // StreamPriorityIngressTables
  if (device_config.GetStreamPriorityIngressTables().contains(device_id)) {
    return true;
  }

  // StreamPriorityEgressTables
  if (device_config.GetStreamPriorityEgressTables().contains(device_id)) {
    return true;
  }

  // GCLTables
  if (device_config.GetGCLTables().contains(device_id)) {
    return true;
  }

  // CbTables
  if (device_config.GetCbTables().contains(device_id)) {
    return true;
  }

  // RstpTables
  if (device_config.GetRstpTables().contains(device_id)) {
    return true;
  }

  // Not DeviceConfig has the device
  return false;
}

ACT_STATUS AutoGenerateDeployDeviceList(const ActProject &project, QList<qint64> &dev_id_list) {
  ACT_STATUS_INIT();
  ACT_STATUS compute_status = std::make_shared<ActStatusBase>();
  act::topology::ActBroadcastSearch broadcast;
  QList<ActDeviceDistanceEntry> distance_entry_list;

  // Online
  auto online_topology = project.online_topology_;
  bool use_online_topology = online_topology.GetMappingResult().GetDeploy();
  // qInfo() << __func__
  //         << QString("Deploy sequence use the %1 topology")
  //                .arg(use_online_topology ? "Online" : "Offline")
  //                .toStdString()
  //                .c_str();

  // [bugfix:2879] Deploy sequence needs to be calculated using the online topology
  if (use_online_topology) {
    // Online topology
    // Generate online & offline device map
    QMap<qint64, qint64> online_offline_dev_map;  // QMap<OnlineDeviceID, OfflineDeviceID>
    for (auto item : online_topology.GetMappingResult().GetMappingReport()) {
      if ((item.GetOfflineDeviceId() != -1) && (item.GetOnlineDeviceId() != -1)) {
        online_offline_dev_map[item.GetOnlineDeviceId()] = item.GetOfflineDeviceId();
      }
    }

    // Use online topology to compute distance
    compute_status = broadcast.ComputeDeviceDistance(online_topology.GetTopology().GetDevices(),
                                                     online_topology.GetTopology().GetLinks(),
                                                     online_topology.GetTopology().GetSourceDeviceId());
    if (IsActStatusSuccess(compute_status)) {
      // Append ActDeviceDistanceEntry to result (Mapping to offline devices)
      for (auto online_dev : online_topology.GetTopology().GetDevices()) {
        if (online_offline_dev_map.contains(online_dev.GetId())) {
          distance_entry_list.append(ActDeviceDistanceEntry(online_offline_dev_map[online_dev.GetId()],
                                                            online_dev.GetDistance(), online_dev.mac_address_int));
        }
      }
      // Sort result by distance from far to near
      std::sort(distance_entry_list.begin(), distance_entry_list.end());
    }

  } else {
    // Offline topology
    // Scan the physical topology to detect the distance
    QList<ActDevice> dev_list = project.GetDevices().values();
    broadcast.SetDevices(dev_list);
    bool from_broadcast_search = false;
    compute_status = broadcast.LinkDistanceDetect(from_broadcast_search, dev_id_list, distance_entry_list);
  }

  if (!IsActStatusSuccess(compute_status)) {
    qWarning() << __func__
               << "Detect distance failed, that the configure sequence uses the IP num (from small to large)";
    dev_id_list.clear();
    distance_entry_list.clear();
    // Sort by IP num (from small to large)
    quint32 ip_num;
    for (auto dev : project.GetDevices()) {
      dev.GetIpv4().GetIpAddressNumber(ip_num);
      distance_entry_list.append(ActDeviceDistanceEntry(dev.GetId(), ip_num, dev.mac_address_int));
    }
    // rsort
    std::sort(distance_entry_list.rbegin(), distance_entry_list.rend());
  }

  // Generate sorted Device ID list
  for (auto dist_entry : distance_entry_list) {
    dev_id_list.append(dist_entry.GetId());
  }
  return ACT_STATUS_SUCCESS;
}

ACT_STATUS SortDeviceIdList(const ActProject &project, QList<qint64> &dev_id_list) {
  ACT_STATUS_INIT();

  QList<qint64> new_dev_id_list;

  QList<qint64> all_dev_sort_id_list;
  AutoGenerateDeployDeviceList(project, all_dev_sort_id_list);

  // Generate sorted Device ID list
  for (auto dev_id : all_dev_sort_id_list) {
    if (dev_id_list.contains(dev_id)) {
      new_dev_id_list.append(dev_id);
    }
  }
  dev_id_list = new_dev_id_list;

  return act_status;
}

void ActCore::OpcUaStartDeployIniThread(qint64 project_id, QList<qint64> dev_id_list, bool skip_mapping_dev,
                                        std::future<void> signal_receiver,
                                        void (*cb_func)(ACT_STATUS status, void *arg), void *arg) {
  ACT_STATUS_INIT();

  // Waiting for caller thread
  std::this_thread::yield();

  // Get project by id
  ActProject project;
  act_status = this->GetProject(project_id, project);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << "Get project failed with project id:" << project_id;
    cb_func(act_status, arg);
    return;
  }
  auto backup_project = project;

  // Check device exist
  for (auto dev_id : dev_id_list) {
    ActDevice dev;
    act_status = project.GetDeviceById(dev, dev_id);  // find project's device by id
    if (IsActStatusNotFound(act_status)) {            // not found device
      qCritical() << __func__ << "Project has no device id:" << dev_id;
      cb_func(act_status, arg);
      return;
    }
  }

  // Generate the all can deploy device (if empty)
  if (dev_id_list.isEmpty()) {
    for (auto device : project.GetDevices()) {
      if (device.CheckCanDeploy()) {
        dev_id_list.append(device.GetId());
      }
    }
  }

  SortDeviceIdList(project, dev_id_list);

  // Check empty
  if (dev_id_list.isEmpty()) {
    qCritical() << __func__ << "Deploy list is empty";
    act_status = std::make_shared<ActStatusInternalError>("Deploy");
    cb_func(act_status, arg);
    return;
  }

  // Clear DeviceConfig tmp folder
  // kene+
  /*
  act_status = ClearFolder(ACT_DEVICE_CONFIG_FILE_FOLDER);
  */
  act_status = ClearFolder(GetDeviceConfigFilePath());
  // kene-
  if (!IsActStatusSuccess(act_status)) {
    cb_func(act_status, arg);
    return;
  }

  // Generate the ini file
  ActDeviceOfflineConfigFileMap device_offline_config_file_map;
  act_status = GenerateDeviceIniConfigFile(project, dev_id_list, device_offline_config_file_map);
  if (!IsActStatusSuccess(act_status)) {
    cb_func(act_status, arg);
    return;
  }

  // Check map[deviceId] has value (generated offline config)
  act_status = CheckDeviceConfigValuesNotEmpty(project, dev_id_list, device_offline_config_file_map);
  if (!IsActStatusSuccess(act_status)) {
    cb_func(act_status, arg);
    return;
  }

  // Trigger deploy procedure
  QMap<QString, QString> mac_host_map;
  this->GetMacHostMap(mac_host_map);
  ActProfiles profiles(this->GetFeatureProfileSet(), this->GetFirmwareFeatureProfileSet(), this->GetDeviceProfileSet(),
                       this->GetDefaultDeviceProfileSet());
  act::deploy::ActDeploy deployer(profiles, mac_host_map);

  act_status = deployer.StartIniDeployer(project, dev_id_list, skip_mapping_dev);
  if (!IsActStatusRunning(act_status)) {
    qCritical() << project.GetProjectName() << "Start ini deployer failed";
    cb_func(act_status, arg);
    return;
  }

  this->project_status_list[project_id] = ActProjectStatusEnum::kDeploying;

  // Reference: https://thispointer.com/c11-how-to-stop-or-terminate-a-thread/
  while (signal_receiver.wait_for(std::chrono::seconds(1)) == std::future_status::timeout) {
    act_status = deployer.GetStatus();

    // Dequeue
    while (!deployer.result_queue_.isEmpty()) {
      ActDeviceConfigureResult dev_config_result = deployer.result_queue_.dequeue();
      // ActDeviceConfigResultWSResponse ws_resp(ActWSCommandEnum::kStartDeploy, ActStatusType::kRunning,
      //                                         dev_config_result);
      // this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    }

    // Dequeue Update account
    while (!deployer.update_account_queue_.isEmpty()) {
      auto deviceid_account_pair = deployer.update_account_queue_.dequeue();
      ActDevice device;
      project.GetDeviceById(device, deviceid_account_pair.first);
      device.SetAccount(deviceid_account_pair.second);
      auto update_status = this->UpdateDevice(project, device);
      if (!IsActStatusSuccess(update_status)) {
        qWarning() << "Update device failed with device id:" << device.GetId();
      }
    }

    if (act_status->GetStatus() != ActStatusType::kRunning) {
      if (act_status->GetStatus() != ActStatusType::kFinished) {
        // error
        cb_func(act_status, arg);
      }

      break;
    } else {  // update pure progress
      cb_func(act_status, arg);
    }
  }

  qDebug() << project.GetProjectName() << "Thread is going to close";

  // [bugfix:2141] call stop need to abort immediately
  if (act_status->GetStatus() == ActStatusType::kRunning) {
    deployer.Stop();
    qCritical() << project.GetProjectName() << "Abort deploy ini";

    this->project_status_list[project_id] = ActProjectStatusEnum::kAborted;

    cb_func(ACT_STATUS_STOP, arg);
    return;
  }

  this->project_status_list[project_id] = ActProjectStatusEnum::kFinished;

  // [feat:793] Update the stream status of all streams to scheduled (802.1Qdj)
  act_status = this->UpdateAllStreamStatus(project, ActStreamStatusEnum::kScheduled);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << project.GetProjectName() << "Cannot update the stream status";
    cb_func(act_status, arg);
    return;
  }

  act_status = this->UpdateProject(project);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << project.GetProjectName() << "Cannot update the project";
    cb_func(act_status, arg);

    // If update failed would update the backup_project
    act_status = this->UpdateProject(backup_project);
    if (!IsActStatusSuccess(act_status)) {
      qCritical() << project.GetProjectName() << "Cannot update the backup project";
    }
    return;
  }

  // Remove by v0.8.0
  // // Copy Project to monitor stage
  // qint64 copy_project_id = -1;
  // if (this->GetLicense().GetFeature().GetStage().GetManufacture() && deployer.failed_device_id_set_.isEmpty()) {
  //   auto copy_project = project;
  //   copy_project.SetProjectMode(ActProjectModeEnum::kOperation);
  //   // If project exists would replace it
  //   QSet<ActProject> sys_project_set = this->GetProjectSet();
  //   for (ActProject sys_project : sys_project_set) {
  //     if (sys_project.GetUUID() == copy_project.GetUUID() &&
  //         sys_project.GetProjectMode() == ActProjectModeEnum::kOperation) {
  //       // Remove exists project
  //       act_status = this->DeleteProject(sys_project.GetId(), true);
  //       if (!IsActStatusSuccess(act_status)) {
  //         qWarning() << __func__ << "Delete Monitor Project failed";
  //       }
  //     }
  //   }
  //   act_status = this->CreateProject(copy_project);
  //   if (!IsActStatusSuccess(act_status)) {
  //     qWarning() << __func__ << "Create Monitor Project failed";
  //   }

  //   copy_project_id = copy_project.GetId();

  //   qDebug() << __func__ << "Create Monitor Project(" << copy_project_id << ")";
  // }

  // Send finished status & report reply to client
  act_status = deployer.GetStatus();
  cb_func(act_status, arg);

  return;
}

ACT_STATUS ActCore::OpcUaStartDeployIni(qint64 &project_id, const QList<qint64> &dev_id_list,
                                        const bool &skip_mapping_dev, std::future<void> signal_receiver,
                                        void (*cb_func)(ACT_STATUS status, void *arg), void *arg) {
  ACT_STATUS_INIT();

  this->InitNotificationTmp();

  // Check job can start
  QString project_name;
  act_status = this->CheckWSJobCanStart(ActProjectStatusEnum::kDeploying, project_id, project_name);
  if (!IsActStatusSuccess(act_status)) {  // thread can't start
    return act_status;
  }

  // Create a std::promise object
  std::shared_ptr<std::promise<void>> signal_sender = std::make_shared<std::promise<void>>();

  qDebug() << project_name << "Spawn OPC UA deploy ini thread...";
  std::shared_ptr<std::thread> thread_ptr;

  thread_ptr = std::make_shared<std::thread>(&act::core::ActCore::OpcUaStartDeployIniThread, this, project_id,
                                             dev_id_list, skip_mapping_dev, std::move(signal_receiver), cb_func, arg);

#ifdef _WIN32
  // Set the thread name
  std::wstring thread_name = L"OpcUaStartDeployIniThread";
  HRESULT hr = SetThreadDescription(thread_ptr->native_handle(), thread_name.c_str());
  if (FAILED(hr)) {
    // Handle error
  }
#endif

  // Insert thread handler to pools
  qDebug() << project_name << "Insert thread handler to pools...";
  ws_thread_handler_pools.insert(project_id, make_pair(signal_sender, thread_ptr));

  return act_status;
}

void ActCore::StartDeployThread(const qint64 &ws_listener_id, std::future<void> signal_receiver, qint64 project_id,
                                QList<qint64> dev_id_list, ActDeployActionEnum action, bool skip_mapping_dev,
                                ActDeployParameterBase *parameter_base) {
  ACT_STATUS_INIT();

  // Waiting for caller thread
  std::this_thread::yield();

  // Get project by id
  ActProject project;
  act_status = this->GetProject(project_id, project);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << "Get project failed with project id:" << project_id;

    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return;
  }
  auto backup_project = project;

  // Trigger deploy procedure
  QMap<QString, QString> mac_host_map;
  this->GetMacHostMap(mac_host_map);
  // Southbound module need the feature profile information
  ActProfiles profiles(this->GetFeatureProfileSet(), this->GetFirmwareFeatureProfileSet(), this->GetDeviceProfileSet(),
                       this->GetDefaultDeviceProfileSet());
  act::deploy::ActDeploy deployer(profiles, mac_host_map);

  act::deploy::ActDeployControl deploy_ctrl;

  if (action == ActDeployActionEnum::kReboot) {
    deploy_ctrl.SetReboot(true);
  } else if (action == ActDeployActionEnum::kFactoryDefault) {
    deploy_ctrl.SetFactoryDefault(true);
  } else if (action == ActDeployActionEnum::kFirmwareUpgrade) {
    deploy_ctrl.SetFirmwareUpgrade(true);
  } else if (action == ActDeployActionEnum::kNetworkSetting) {
    deploy_ctrl.SetNetworkSetting(true);
  } else if (action == ActDeployActionEnum::kVLAN) {
    deploy_ctrl.SetVlan(true);
  } else {  // all config

    deploy_ctrl.SetFromBroadcastSearch(false);
    deploy_ctrl.SetNetworkSetting(true);
    deploy_ctrl.SetLoginPolicy(true);
    deploy_ctrl.SetSnmpTrapSetting(true);
    deploy_ctrl.SetSyslogSetting(true);
    deploy_ctrl.SetTimeSetting(true);
    deploy_ctrl.SetPortSetting(true);
    deploy_ctrl.SetInformationSetting(true);
    deploy_ctrl.SetManagementInterface(true);
    deploy_ctrl.SetLoopProtection(true);
    deploy_ctrl.SetVlan(true);
    deploy_ctrl.SetPortDefaultPcp(true);
    deploy_ctrl.SetUnicastStaticForward(true);
    deploy_ctrl.SetMulticastStaticForward(true);
    deploy_ctrl.SetStreamPriorityIngress(true);
    deploy_ctrl.SetStreamPriorityEgress(true);
    deploy_ctrl.SetGcl(true);
    deploy_ctrl.SetIeee802Dot1Cb(true);
    deploy_ctrl.SetSpanningTree(true);
  }

  // Generate the device_id_list when that is empty
  if (dev_id_list.isEmpty()) {
    act_status = AutoGenerateDeployDeviceList(project, dev_id_list);
    if (!IsActStatusSuccess(act_status)) {
      qCritical() << project.GetProjectName() << "Generate the deploy devices list failed";

      std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
          ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
      this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);

      return;
    }
  }

  // Filter the device by device type
  auto tmp_dev_id_list = dev_id_list;
  for (auto dev_id : tmp_dev_id_list) {
    ActDevice dev;
    project.GetDeviceById(dev, dev_id);
    if (!ActDevice::CheckDeviceCanBeDeploy(dev)) {
      // CheckDeviceCanBeDeploy
      dev_id_list.removeAll(dev_id);
    }
  }

  // Filter the device if it hasn't DeviceConfig
  tmp_dev_id_list = dev_id_list;
  for (auto dev_id : tmp_dev_id_list) {
    if (!CheckDeviceInDeviceConfig(project.GetDeviceConfig(), dev_id)) {
      dev_id_list.removeAll(dev_id);
    }
  }

  act_status = deployer.Start(project, dev_id_list, deploy_ctrl, skip_mapping_dev, parameter_base);
  if (!IsActStatusRunning(act_status)) {
    qCritical() << project.GetProjectName() << "Start deploy failed";

    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);

    return;
  }

  this->project_status_list[project_id] = ActProjectStatusEnum::kDeploying;

  // Reference: https://thispointer.com/c11-how-to-stop-or-terminate-a-thread/
  while (signal_receiver.wait_for(std::chrono::seconds(1)) == std::future_status::timeout) {
    act_status = deployer.GetStatus();

    // Dequeue
    while (!deployer.result_queue_.isEmpty()) {
      ActDeviceConfigureResult dev_config_result = deployer.result_queue_.dequeue();
      ActDeviceConfigResultWSResponse ws_resp(ActWSCommandEnum::kStartDeploy, ActStatusType::kRunning,
                                              dev_config_result);
      // qDebug() << __func__ << ws_resp.ToString(ws_resp.key_order_).toStdString().c_str();
      this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    }

    if (act_status->GetStatus() != ActStatusType::kRunning) {
      if (act_status->GetStatus() != ActStatusType::kFinished) {
        // error
        std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
            ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
        qDebug() << ws_resp->ToString(ws_resp->key_order_).toStdString().c_str();
        this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
      }

      break;
    } else {  // update pure progress
      ActProgressWSResponse ws_resp(ActWSCommandEnum::kStartDeploy, dynamic_cast<ActProgressStatus &>(*act_status));
      this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    }
  }

  qDebug() << project.GetProjectName() << "Thread is going to close";

  // [bugfix:2141] call stop need to abort immediately
  if (act_status->GetStatus() == ActStatusType::kRunning) {
    deployer.Stop();
    qCritical() << project.GetProjectName() << "Abort deploy";

    this->project_status_list[project_id] = ActProjectStatusEnum::kAborted;
    return;
  }

  this->project_status_list[project_id] = ActProjectStatusEnum::kFinished;

  // Update project's devices set, if success config NetworkSetting
  if (deploy_ctrl.GetNetworkSetting()) {
    for (auto network_setting_table : project.GetDeviceConfig().GetNetworkSettingTables()) {
      if (deployer.GetNetworkSettingSuccessDevices().contains(network_setting_table.GetDeviceId())) {
        // Get project's Device by id
        ActDevice device;
        act_status = ActGetItemById<ActDevice>(project.GetDevices(), network_setting_table.GetDeviceId(), device);

        if (!IsActStatusSuccess(act_status)) {
          qCritical() << "Get device failed. id:" << project_id;
          std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
              ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
          this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
          return;
        }

        // Update device's Ipv4
        auto &ipv4 = device.GetIpv4();
        ipv4.SetIpAddress(network_setting_table.GetIpAddress());
        ipv4.SetSubnetMask(network_setting_table.GetSubnetMask());
        ipv4.SetGateway(network_setting_table.GetGateway());
        ipv4.SetDNS1(network_setting_table.GetDNS1());
        ipv4.SetDNS2(network_setting_table.GetDNS2());

        act_status = this->UpdateDevice(project, device);
        if (!IsActStatusSuccess(act_status)) {
          qCritical() << "Update device failed with device id:" << device.GetId();
          std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
              ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
          this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
          return;
        }
      }
    }
  }

  // qDebug() << "Send Websocket update msg from NotificationTmp";
  // Send Websocket update msg from NotificationTmp
  this->SendMessageToListener(ActWSTypeEnum::kProject, true, ActBasePatchUpdateMsg(), project_id);

  // [feat:793] Update the stream status of all streams to scheduled (802.1Qdj)
  act_status = this->UpdateAllStreamStatus(project, ActStreamStatusEnum::kScheduled);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << project.GetProjectName() << "Cannot update the stream status";
    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return;
  }

  act_status = this->UpdateProject(project);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << project.GetProjectName() << "Cannot update the project";
    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);

    // If update failed would update the backup_project
    act_status = this->UpdateProject(backup_project);
    if (!IsActStatusSuccess(act_status)) {
      qCritical() << project.GetProjectName() << "Cannot update the backup project";
    }
    return;
  }

  // Send finished status reply to client
  ActBaseResponse ws_resp(ActWSCommandEnum::kStartDeploy, ActStatusType::kFinished);
  qDebug() << __func__ << ws_resp.ToString(ws_resp.key_order_).toStdString().c_str();
  this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);

  return;
}

ACT_STATUS ActCore::StartDeploy(qint64 &project_id, const qint64 &ws_listener_id, const QList<qint64> &dev_id_list,
                                const ActDeployActionEnum &action, const bool &skip_mapping_dev,
                                ActDeployParameterBase *parameter_base) {
  ACT_STATUS_INIT();

  this->InitNotificationTmp();

  // Check job can start
  QString project_name;
  act_status = this->CheckWSJobCanStart(ActProjectStatusEnum::kDeploying, project_id, project_name);
  if (!IsActStatusSuccess(act_status)) {  // thread can't start

    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return act_status;
  }

  // Create a std::promise object
  std::shared_ptr<std::promise<void>> signal_sender = std::make_shared<std::promise<void>>();

  // Fetch std::future object associated with promise
  std::future<void> signal_receiver = signal_sender->get_future();

  qDebug() << project_name << "Spawn deploy thread...";
  std::shared_ptr<std::thread> thread_ptr;

  thread_ptr = std::make_shared<std::thread>(&act::core::ActCore::StartDeployThread, this, std::cref(ws_listener_id),
                                             std::move(signal_receiver), project_id, dev_id_list, action,
                                             skip_mapping_dev, parameter_base);

#ifdef _WIN32
  // Set the thread name
  std::wstring thread_name = L"StartDeployThread";
  HRESULT hr = SetThreadDescription(thread_ptr->native_handle(), thread_name.c_str());
  if (FAILED(hr)) {
    // Handle error
  }
#endif

  // Insert thread handler to pools
  qDebug() << project_name << "Insert thread handler to pools...";
  ws_thread_handler_pools.insert(project_id, make_pair(signal_sender, thread_ptr));

  return act_status;
}

void ActCore::StartDeployIniThread(const qint64 &ws_listener_id, std::future<void> signal_receiver, qint64 project_id,
                                   QList<qint64> dev_id_list, bool skip_mapping_dev) {
  ACT_STATUS_INIT();

  // Waiting for caller thread
  std::this_thread::yield();

  // Get project by id
  ActProject project;
  act_status = this->GetProject(project_id, project);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << "Get project failed with project id:" << project_id;

    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return;
  }
  auto backup_project = project;

  // Check device exist
  for (auto dev_id : dev_id_list) {
    ActDevice dev;
    act_status = project.GetDeviceById(dev, dev_id);  // find project's device by id
    if (IsActStatusNotFound(act_status)) {            // not found device
      qCritical() << __func__ << "Project has no device id:" << dev_id;

      std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
          ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
      this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
      return;
    }
  }

  // Generate the all can deploy device (if empty)
  if (dev_id_list.isEmpty()) {
    for (auto device : project.GetDevices()) {
      if (device.CheckCanDeploy()) {
        dev_id_list.append(device.GetId());
      }
    }
  }

  SortDeviceIdList(project, dev_id_list);

  // Check empty
  if (dev_id_list.isEmpty()) {
    qCritical() << __func__ << "Deploy list is empty";
    act_status = std::make_shared<ActStatusInternalError>("Deploy");
    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return;
  }

  // Clear DeviceConfig tmp folder
  // kene+
  /*
  act_status = ClearFolder(ACT_DEVICE_CONFIG_FILE_FOLDER);
  */
  act_status = ClearFolder(GetDeviceConfigFilePath());
  // kene-
  if (!IsActStatusSuccess(act_status)) {
    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return;
  }

  // Generate the ini file
  ActDeviceOfflineConfigFileMap device_offline_config_file_map;
  act_status = GenerateDeviceIniConfigFile(project, dev_id_list, device_offline_config_file_map);
  if (!IsActStatusSuccess(act_status)) {
    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return;
  }

  // Check map[deviceId] has value (generated offline config)
  act_status = CheckDeviceConfigValuesNotEmpty(project, dev_id_list, device_offline_config_file_map);
  if (!IsActStatusSuccess(act_status)) {
    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return;
  }

  // Trigger deploy procedure
  QMap<QString, QString> mac_host_map;
  this->GetMacHostMap(mac_host_map);
  ActProfiles profiles(this->GetFeatureProfileSet(), this->GetFirmwareFeatureProfileSet(), this->GetDeviceProfileSet(),
                       this->GetDefaultDeviceProfileSet());
  act::deploy::ActDeploy deployer(profiles, mac_host_map);

  act_status = deployer.StartIniDeployer(project, dev_id_list, skip_mapping_dev);
  if (!IsActStatusRunning(act_status)) {
    qCritical() << project.GetProjectName() << "Start ini deployer failed";

    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);

    return;
  }

  this->project_status_list[project_id] = ActProjectStatusEnum::kDeploying;

  // Reference: https://thispointer.com/c11-how-to-stop-or-terminate-a-thread/
  while (signal_receiver.wait_for(std::chrono::seconds(1)) == std::future_status::timeout) {
    act_status = deployer.GetStatus();

    // Dequeue result
    while (!deployer.result_queue_.isEmpty()) {
      ActDeviceConfigureResult dev_config_result = deployer.result_queue_.dequeue();
      ActDeviceConfigResultWSResponse ws_resp(ActWSCommandEnum::kStartDeploy, ActStatusType::kRunning,
                                              dev_config_result);
      this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    }

    // Dequeue Update account
    while (!deployer.update_account_queue_.isEmpty()) {
      auto deviceid_account_pair = deployer.update_account_queue_.dequeue();
      ActDevice device;
      project.GetDeviceById(device, deviceid_account_pair.first);
      device.SetAccount(deviceid_account_pair.second);
      auto update_status = this->UpdateDevice(project, device);
      if (!IsActStatusSuccess(update_status)) {
        qWarning() << "Update device failed with device id:" << device.GetId();
      }
      // Notify the user that the device be update
      ActDevicePatchUpdateMsg msg(ActPatchUpdateActionEnum::kUpdate, project_id, device, true);
      this->SendMessageToListener(ActWSTypeEnum::kProject, false, msg, project_id);
    }

    if (act_status->GetStatus() != ActStatusType::kRunning) {
      if (act_status->GetStatus() != ActStatusType::kFinished) {
        // error
        std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
            ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
        qDebug() << ws_resp->ToString(ws_resp->key_order_).toStdString().c_str();
        this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
      }

      break;
    } else {  // update pure progress
      ActProgressWSResponse ws_resp(ActWSCommandEnum::kStartDeploy, dynamic_cast<ActProgressStatus &>(*act_status));
      this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    }
  }

  qDebug() << project.GetProjectName() << "Thread is going to close";

  // [bugfix:2141] call stop need to abort immediately
  if (act_status->GetStatus() == ActStatusType::kRunning) {
    deployer.Stop();
    qCritical() << project.GetProjectName() << "Abort deploy ini";

    this->project_status_list[project_id] = ActProjectStatusEnum::kAborted;
    return;
  }

  this->project_status_list[project_id] = ActProjectStatusEnum::kFinished;

  // [feat:793] Update the stream status of all streams to scheduled (802.1Qdj)
  act_status = this->UpdateAllStreamStatus(project, ActStreamStatusEnum::kScheduled);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << project.GetProjectName() << "Cannot update the stream status";
    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return;
  }

  act_status = this->UpdateProject(project);
  if (!IsActStatusSuccess(act_status)) {
    qCritical() << project.GetProjectName() << "Cannot update the project";
    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);

    // If update failed would update the backup_project
    act_status = this->UpdateProject(backup_project);
    if (!IsActStatusSuccess(act_status)) {
      qCritical() << project.GetProjectName() << "Cannot update the backup project";
    }
    return;
  }

  // Remove by v0.8.0
  // // Copy Project to monitor stage
  // qint64 copy_project_id = -1;
  // if (this->GetLicense().GetFeature().GetStage().GetManufacture() && deployer.failed_device_id_set_.isEmpty()) {
  //   auto copy_project = project;
  //   copy_project.SetProjectMode(ActProjectModeEnum::kOperation);
  //   // If project exists would replace it
  //   QSet<ActProject> sys_project_set = this->GetProjectSet();
  //   for (ActProject sys_project : sys_project_set) {
  //     if (sys_project.GetUUID() == copy_project.GetUUID() &&
  //         sys_project.GetProjectMode() == ActProjectModeEnum::kOperation) {
  //       // Remove exists project
  //       act_status = this->DeleteProject(sys_project.GetId(), true);
  //       if (!IsActStatusSuccess(act_status)) {
  //         qWarning() << __func__ << "Delete Monitor Project failed";
  //       }
  //     }
  //   }
  //   act_status = this->CreateProject(copy_project);
  //   if (!IsActStatusSuccess(act_status)) {
  //     qWarning() << __func__ << "Create Monitor Project failed";
  //   }
  //   copy_project_id = copy_project.GetId();
  //   qDebug() << __func__ << "Create Monitor Project(" << copy_project_id << ")";

  //   // [feat:3830] Auto-create a baseline when uploading the project to the monitor stage
  //   // ActUser user;
  //   // act::core::g_core.GetUser(copy_project.GetUserId(), user);
  //   ActNetworkBaseline network_baseline;
  //   act_status = this->CreateNetworkBaseline(copy_project_id, ACT_NETWORK_BASELINE_INITIAL_NAME,
  //                                            ACT_NETWORK_BASELINE_INITIAL_CREATED_USER, network_baseline);
  //   if (!IsActStatusSuccess(act_status)) {
  //     qWarning() << __func__ << "Create Initial NetworkBaseline failed";
  //   }
  // }

  // Send finished status & report reply to client
  ActDeployIniResultWSResponse ws_resp(ActWSCommandEnum::kStartDeploy);
  qDebug() << __func__ << ws_resp.ToString(ws_resp.key_order_).toStdString().c_str();
  this->SendMessageToWSListener(ws_listener_id, ws_resp.ToString(ws_resp.key_order_).toStdString().c_str());

  return;
}

ACT_STATUS ActCore::StartDeployIni(qint64 &project_id, const qint64 &ws_listener_id, const QList<qint64> &dev_id_list,
                                   const bool &skip_mapping_dev) {
  ACT_STATUS_INIT();

  this->InitNotificationTmp();

  // Check job can start
  QString project_name;
  act_status = this->CheckWSJobCanStart(ActProjectStatusEnum::kDeploying, project_id, project_name);
  if (!IsActStatusSuccess(act_status)) {  // thread can't start

    std::shared_ptr<ActBaseErrorMessageResponse> ws_resp =
        ActWSResponseErrorTransfer(ActWSCommandEnum::kStartDeploy, *act_status);
    this->SendMessageToListener(ActWSTypeEnum::kSpecified, false, ws_resp, ws_listener_id);
    return act_status;
  }

  // Create a std::promise object
  std::shared_ptr<std::promise<void>> signal_sender = std::make_shared<std::promise<void>>();

  // Fetch std::future object associated with promise
  std::future<void> signal_receiver = signal_sender->get_future();

  qDebug() << project_name << "Spawn deploy ini thread...";
  std::shared_ptr<std::thread> thread_ptr;

  thread_ptr = std::make_shared<std::thread>(&act::core::ActCore::StartDeployIniThread, this, std::cref(ws_listener_id),
                                             std::move(signal_receiver), project_id, dev_id_list, skip_mapping_dev);

#ifdef _WIN32
  // Set the thread name
  std::wstring thread_name = L"StartDeployIniThread";
  HRESULT hr = SetThreadDescription(thread_ptr->native_handle(), thread_name.c_str());
  if (FAILED(hr)) {
    // Handle error
  }
#endif

  // Insert thread handler to pools
  qDebug() << project_name << "Insert thread handler to pools...";
  ws_thread_handler_pools.insert(project_id, make_pair(signal_sender, thread_ptr));

  return act_status;
}

}  // namespace core
}  // namespace act
