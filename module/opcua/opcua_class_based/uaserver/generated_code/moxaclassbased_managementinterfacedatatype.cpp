/******************************************************************************
** moxaclassbased_managementinterfacedatatype.cpp
**
**   **************************** auto-generated ****************************
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.8.0, using C++ OPC UA SDK 1.8.2 template (version 4)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
**   **************************** auto-generated ****************************
**
** Copyright (c) 2006-2025 Unified Automation GmbH. All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
** Project: C++ OPC Server SDK information model for namespace http://www.moxa.com/auto-configuration-tool-class-based-model/
**
** Description: OPC Unified Architecture Software Development Kit.
**
******************************************************************************/

#include "moxaclassbased_managementinterfacedatatype.h"

#include <opcua_datetime.h>

#include "uavariant.h"
#include "uadatavalue.h"
#include "uaextensionobject.h"
#include "uaatomic.h"

// Namespace for the UA information model http://www.moxa.com/auto-configuration-tool-class-based-model/
namespace MoxaClassBased {

/******************************************************************************
** Class ManagementInterfaceDataTypePrivate
******************************************************************************/
class ManagementInterfaceDataTypePrivate : private MoxaClassBased_ManagementInterfaceDataType
{
    ManagementInterfaceDataTypePrivate(const ManagementInterfaceDataTypePrivate &other);
    ManagementInterfaceDataTypePrivate& operator=(const ManagementInterfaceDataTypePrivate&);
public:
    ManagementInterfaceDataTypePrivate();
    explicit ManagementInterfaceDataTypePrivate(bool bStatic);
    explicit ManagementInterfaceDataTypePrivate(const MoxaClassBased_ManagementInterfaceDataType &other);
    ~ManagementInterfaceDataTypePrivate();

    int addRef();
    int release();
    inline int refCount() { return m_iRefCnt; }

private:
    int m_iRefCnt;
    friend class ManagementInterfaceDataType;
};

/* construction */
ManagementInterfaceDataTypePrivate::ManagementInterfaceDataTypePrivate()
 : m_iRefCnt(0)
{
    MoxaClassBased_ManagementInterfaceDataType_Initialize(this);
}

/*  Static initializer.
 *  This is used internaly to initialize the static shared_emtpy variable.
 *  RefCnt is set to 1 so it will never be deleted.
 */
ManagementInterfaceDataTypePrivate::ManagementInterfaceDataTypePrivate(bool)
 : m_iRefCnt(1)
{
    MoxaClassBased_ManagementInterfaceDataType_Initialize(this);
}


/*  construction
 */
ManagementInterfaceDataTypePrivate::ManagementInterfaceDataTypePrivate(const MoxaClassBased_ManagementInterfaceDataType &other) // [in] the other MoxaClassBased_ManagementInterfaceDataType.
 : m_iRefCnt(0)
{
    MoxaClassBased_ManagementInterfaceDataType_CopyTo(&other, this);
}

/* destruction */
ManagementInterfaceDataTypePrivate::~ManagementInterfaceDataTypePrivate()
{
    MoxaClassBased_ManagementInterfaceDataType_Clear(this);
}

/*  Add a reference to a ManagementInterfaceDataTypePrivate
 *  @return 0 if the object was deleted - otherwise a value bigger than 0.
 *  This method is not thread save regarding the return value. The returned counter is only reliable when it is 0.
 *  Other values are not reliable and should not be used for any logic.
 */
int ManagementInterfaceDataTypePrivate::addRef()
{
    return ua_atomic_increment(&m_iRefCnt);
}

/*  Release a ManagementInterfaceDataTypePrivate.
 *  @return the reference count.
 */
int ManagementInterfaceDataTypePrivate::release()
{
    int currentCount = ua_atomic_decrement(&m_iRefCnt);
    if (currentCount == 0)
    {
        delete this;
    }
    return currentCount;
}

ManagementInterfaceDataTypePrivate* shared_empty_ManagementInterfaceDataType()
{
    static ManagementInterfaceDataTypePrivate shared_static(true);
    return &shared_static;
}


/******************************************************************************
** Class ManagementInterfaceDataType
******************************************************************************/

/** Constructs an instance of the class ManagementInterfaceDataType with empty default values
*/
ManagementInterfaceDataType::ManagementInterfaceDataType()
{
    d_ptr = shared_empty_ManagementInterfaceDataType();
    d_ptr->addRef();
}

/** Constructs an instance of the class ManagementInterfaceDataType with values from another ManagementInterfaceDataType object
 *  @param other the other UaManagementInterfaceDataType used to initialize the object
 */
ManagementInterfaceDataType::ManagementInterfaceDataType(const ManagementInterfaceDataType &other)
{
    d_ptr = other.d_ptr;
    d_ptr->addRef();
}

/** Constructs an instance of the class ManagementInterfaceDataType with values from another MoxaClassBased_ManagementInterfaceDataType structure
 *  @param other the other MoxaClassBased_ManagementInterfaceDataType used to initialize the object
 */
ManagementInterfaceDataType::ManagementInterfaceDataType(const MoxaClassBased_ManagementInterfaceDataType &other)
{
    d_ptr = new ManagementInterfaceDataTypePrivate(other);
    d_ptr->addRef();
}

/** Constructs an instance of the class ManagementInterfaceDataType initialized with value from a UaExtensionObject
 *  @param extensionObject the extension object containing the ManagementInterfaceDataType
 */
ManagementInterfaceDataType::ManagementInterfaceDataType(const UaExtensionObject &extensionObject)
{
    d_ptr = new ManagementInterfaceDataTypePrivate();
    d_ptr->addRef();

    const OpcUa_ExtensionObject *pExtensionObject = (const OpcUa_ExtensionObject*)extensionObject;
    MoxaClassBased_ManagementInterfaceDataType *pManagementInterfaceDataType = MOXACLASSBASED_EXTENSIONOBJECT_GET_ENCODEABLE(ManagementInterfaceDataType, pExtensionObject);

    if (pManagementInterfaceDataType)
    {
        MoxaClassBased_ManagementInterfaceDataType_CopyTo(pManagementInterfaceDataType, d_ptr);
    }
}

/** Constructs an instance of the class ManagementInterfaceDataType initialized with value from an OpcUa_ExtensionObject structure
 *  @param extensionObject the extension object containing the ManagementInterfaceDataType
 */
ManagementInterfaceDataType::ManagementInterfaceDataType(const OpcUa_ExtensionObject &extensionObject)
{
    d_ptr = new ManagementInterfaceDataTypePrivate();
    d_ptr->addRef();

    MoxaClassBased_ManagementInterfaceDataType *pManagementInterfaceDataType = MOXACLASSBASED_EXTENSIONOBJECT_GET_ENCODEABLE(ManagementInterfaceDataType, &extensionObject);

    if (pManagementInterfaceDataType)
    {
        MoxaClassBased_ManagementInterfaceDataType_CopyTo(pManagementInterfaceDataType, d_ptr);
    }
}

ManagementInterfaceDataType::ManagementInterfaceDataType(UaExtensionObject &extensionObject, OpcUa_Boolean bDetach)
{
    d_ptr = new ManagementInterfaceDataTypePrivate();
    d_ptr->addRef();

    const OpcUa_ExtensionObject *pExtensionObject = (const OpcUa_ExtensionObject*)extensionObject;
    MoxaClassBased_ManagementInterfaceDataType *pManagementInterfaceDataType = MOXACLASSBASED_EXTENSIONOBJECT_GET_ENCODEABLE(ManagementInterfaceDataType, pExtensionObject);
    if (pManagementInterfaceDataType)
    {
        if (bDetach == OpcUa_False)
        {
            MoxaClassBased_ManagementInterfaceDataType_CopyTo(pManagementInterfaceDataType, d_ptr);
        }
        else
        {
            (*(MoxaClassBased_ManagementInterfaceDataType*)d_ptr) = *pManagementInterfaceDataType;
            MoxaClassBased_ManagementInterfaceDataType_Initialize(pManagementInterfaceDataType);
            extensionObject.clear();
        }
    }
}

ManagementInterfaceDataType::ManagementInterfaceDataType(OpcUa_ExtensionObject &extensionObject, OpcUa_Boolean bDetach)
{
    d_ptr = new ManagementInterfaceDataTypePrivate();
    d_ptr->addRef();

    MoxaClassBased_ManagementInterfaceDataType *pManagementInterfaceDataType = MOXACLASSBASED_EXTENSIONOBJECT_GET_ENCODEABLE(ManagementInterfaceDataType, &extensionObject);

    if (pManagementInterfaceDataType)
    {
        if (bDetach == OpcUa_False)
        {
            MoxaClassBased_ManagementInterfaceDataType_CopyTo(pManagementInterfaceDataType, d_ptr);
        }
        else
        {
            (*(MoxaClassBased_ManagementInterfaceDataType*)d_ptr) = *pManagementInterfaceDataType;
            MoxaClassBased_ManagementInterfaceDataType_Initialize(pManagementInterfaceDataType);
            OpcUa_ExtensionObject_Clear(&extensionObject);
        }
    }
}

/** Destroys the ManagementInterfaceDataType object
*/
ManagementInterfaceDataType::~ManagementInterfaceDataType()
{
    MOXACLASSBASED_D(ManagementInterfaceDataType);
    d->release();
}

/** Clear the data of the ManagementInterfaceDataType.
*/
void ManagementInterfaceDataType::clear()
{
    d_ptr->release();
    d_ptr = shared_empty_ManagementInterfaceDataType();
    d_ptr->addRef();
}

/** Compare two ManagementInterfaceDataType if they are similar.
 *  @param other the ManagementInterfaceDataType to compare.
 *  @return true if similar, false if not.
 */
bool ManagementInterfaceDataType::operator==(const ManagementInterfaceDataType &other) const
{
    return (MoxaClassBased_ManagementInterfaceDataType_Compare(d_ptr, other.d_ptr) == 0);
}

/** Returns true if the other ManagementInterfaceDataType is not equal to this.
 *  @see operator==
 *  @param other the ManagementInterfaceDataType to compare.
 *  @return true if other is not equal to this.
 */
bool ManagementInterfaceDataType::operator!=(const ManagementInterfaceDataType &other) const
{
    return !(operator==(other));
}

/** Assignment operator.
 *  @param other the ManagementInterfaceDataType to assign.
 *  @return Assignment operator.
 */
ManagementInterfaceDataType& ManagementInterfaceDataType::operator=(const ManagementInterfaceDataType &other)
{
    other.d_ptr->addRef();
    d_ptr->release();
    d_ptr = other.d_ptr;
    return *this;
}

/** Copy ManagementInterfaceDataType data to a newly allocated MoxaClassBased_ManagementInterfaceDataType.
 *  @return data to a newly allocated MoxaClassBased_ManagementInterfaceDataType.
 */
MoxaClassBased_ManagementInterfaceDataType* ManagementInterfaceDataType::copy() const
{
    return clone(*d_ptr);
}

/** Copy ManagementInterfaceDataType data to an existing MoxaClassBased_ManagementInterfaceDataType structure.
 *  @param pDst the destination of this copy operation.
 */
void ManagementInterfaceDataType::copyTo(MoxaClassBased_ManagementInterfaceDataType *pDst) const
{
    if (pDst == OpcUa_Null) return;
    cloneTo(*d_ptr, *pDst);
}

/** Copy MoxaClassBased_ManagementInterfaceDataType data to a newly allocated MoxaClassBased_ManagementInterfaceDataType.
 *  @param source Source to clone.
 *  @return new copy.
 */
MoxaClassBased_ManagementInterfaceDataType* ManagementInterfaceDataType::clone(const MoxaClassBased_ManagementInterfaceDataType& source)
{
    MoxaClassBased_ManagementInterfaceDataType* pManagementInterfaceDataType = OpcUa_Null;
    MoxaClassBased_ManagementInterfaceDataType_Copy(&source, &pManagementInterfaceDataType);
    return pManagementInterfaceDataType;
}

/** Copy MoxaClassBased_ManagementInterfaceDataType data to an existing MoxaClassBased_ManagementInterfaceDataType structure.
 *  @param source the source of the clone operation.
 *  @param copy the destination of the clone operation.
 */
void ManagementInterfaceDataType::cloneTo(const MoxaClassBased_ManagementInterfaceDataType& source, MoxaClassBased_ManagementInterfaceDataType& copy)
{
    MoxaClassBased_ManagementInterfaceDataType_CopyTo(&source, &copy);
}

/** Attaches the data of the parameter pValue.
 * Don't clear the data of pValue afterwards manually, because ManagementInterfaceDataType is responsible for it now.
 */
void ManagementInterfaceDataType::attach(const MoxaClassBased_ManagementInterfaceDataType *pValue) //!< [in] Parameter to attach to.
{
    if (pValue == OpcUa_Null) return;
    if (d_ptr->refCount() == 1)
    {
        MoxaClassBased_ManagementInterfaceDataType_Clear(d_ptr);
    }
    else
    {
        d_ptr->release();
        d_ptr = new ManagementInterfaceDataTypePrivate();
        d_ptr->addRef();
    }
    // copy data value structure (no deep copy)
    OpcUa_MemCpy(d_ptr, sizeof(MoxaClassBased_ManagementInterfaceDataType), (void*)pValue, sizeof(MoxaClassBased_ManagementInterfaceDataType));
}

/** Detaches the internal ManagementInterfaceDataType structure from this class.
 *  This way you take over the control of releasing the ManagementInterfaceDataType data.
 *  If more than one references exist, the data is copied to pDst instead of being detached.
 *  @return If the functions succeeds pDst is returned, otherwise 0 is returned.
 */
MoxaClassBased_ManagementInterfaceDataType* ManagementInterfaceDataType::detach(MoxaClassBased_ManagementInterfaceDataType* pDst) //!< [out] Pointer to MoxaClassBased_ManagementInterfaceDataType structure that receives the ManagementInterfaceDataType data.
{
    if (pDst == OpcUa_Null) return OpcUa_Null;
    if (d_ptr->refCount() == 1)
    {
        OpcUa_MemCpy(pDst, sizeof(MoxaClassBased_ManagementInterfaceDataType), d_ptr, sizeof(MoxaClassBased_ManagementInterfaceDataType));
        // clear internal data without releasing deeper memory
        MoxaClassBased_ManagementInterfaceDataType_Initialize(d_ptr);
    }
    else
    {
        MoxaClassBased_ManagementInterfaceDataType_CopyTo(d_ptr, pDst);
    }
    d_ptr->release();
    d_ptr = shared_empty_ManagementInterfaceDataType();
    d_ptr->addRef();
    return pDst;
}

void ManagementInterfaceDataType::toVariant(UaVariant &variant) const
{
    UaExtensionObject extensionObject;
    toExtensionObject(extensionObject);
    variant.setExtensionObject(extensionObject, OpcUa_True);
}

void ManagementInterfaceDataType::toVariant(OpcUa_Variant &variant) const
{
    OpcUa_Variant_Clear(&variant);
    variant.Datatype = OpcUaType_ExtensionObject;
    variant.ArrayType = OpcUa_VariantArrayType_Scalar;
    variant.Value.ExtensionObject = (OpcUa_ExtensionObject*)OpcUa_Alloc(sizeof(OpcUa_ExtensionObject));
    OpcUa_ExtensionObject_Initialize(variant.Value.ExtensionObject);
    toExtensionObject(*variant.Value.ExtensionObject);
}

void ManagementInterfaceDataType::toVariant(UaVariant &variant, OpcUa_Boolean bDetach)
{
    UaExtensionObject extensionObject;
    toExtensionObject(extensionObject, bDetach);
    variant.setExtensionObject(extensionObject, OpcUa_True);
}

void ManagementInterfaceDataType::toVariant(OpcUa_Variant &variant, OpcUa_Boolean bDetach)
{
    OpcUa_Variant_Clear(&variant);
    variant.Datatype = OpcUaType_ExtensionObject;
    variant.ArrayType = OpcUa_VariantArrayType_Scalar;
    variant.Value.ExtensionObject = (OpcUa_ExtensionObject*)OpcUa_Alloc(sizeof(OpcUa_ExtensionObject));
    OpcUa_ExtensionObject_Initialize(variant.Value.ExtensionObject);
    toExtensionObject(*variant.Value.ExtensionObject, bDetach);
}

void ManagementInterfaceDataType::toDataValue(UaDataValue &dataValue, OpcUa_Boolean updateTimeStamps) const
{
    UaVariant variant;
    toVariant(variant);
    dataValue.setValue(variant, OpcUa_True, updateTimeStamps);
}

void ManagementInterfaceDataType::toDataValue(OpcUa_DataValue &dataValue, OpcUa_Boolean updateTimeStamps) const
{
    OpcUa_Variant_Clear(&dataValue.Value);
    dataValue.Value.Datatype = OpcUaType_ExtensionObject;
    dataValue.Value.ArrayType = OpcUa_VariantArrayType_Scalar;
    dataValue.Value.Value.ExtensionObject = (OpcUa_ExtensionObject*)OpcUa_Alloc(sizeof(OpcUa_ExtensionObject));
    OpcUa_ExtensionObject_Initialize(dataValue.Value.Value.ExtensionObject);
    toExtensionObject(*dataValue.Value.Value.ExtensionObject);

    if (updateTimeStamps != OpcUa_False)
    {
        dataValue.SourceTimestamp = OpcUa_DateTime_UtcNow();
        dataValue.ServerTimestamp = dataValue.SourceTimestamp;
    }
}

void ManagementInterfaceDataType::toDataValue(UaDataValue &dataValue, OpcUa_Boolean bDetach, OpcUa_Boolean updateTimeStamps)
{
    UaVariant variant;
    toVariant(variant, bDetach);
    dataValue.setValue(variant, OpcUa_True, updateTimeStamps);
}

void ManagementInterfaceDataType::toDataValue(OpcUa_DataValue &dataValue, OpcUa_Boolean bDetach, OpcUa_Boolean updateTimeStamps)
{
    OpcUa_Variant_Clear(&dataValue.Value);
    dataValue.Value.Datatype = OpcUaType_ExtensionObject;
    dataValue.Value.ArrayType = OpcUa_VariantArrayType_Scalar;
    dataValue.Value.Value.ExtensionObject = (OpcUa_ExtensionObject*)OpcUa_Alloc(sizeof(OpcUa_ExtensionObject));
    OpcUa_ExtensionObject_Initialize(dataValue.Value.Value.ExtensionObject);
    toExtensionObject(*dataValue.Value.Value.ExtensionObject, bDetach);

    if (updateTimeStamps != OpcUa_False)
    {
        dataValue.SourceTimestamp = OpcUa_DateTime_UtcNow();
        dataValue.ServerTimestamp = dataValue.SourceTimestamp;
    }
}

void ManagementInterfaceDataType::toExtensionObject(UaExtensionObject &extensionObject) const
{
    OpcUa_ExtensionObject *pExtensionObject = (OpcUa_ExtensionObject*)(const OpcUa_ExtensionObject*)extensionObject;
    toExtensionObject(*pExtensionObject);
}

void ManagementInterfaceDataType::toExtensionObject(OpcUa_ExtensionObject &extensionObject) const
{
    OpcUa_ExtensionObject_Clear(&extensionObject);
    MoxaClassBased_ManagementInterfaceDataType *pManagementInterfaceDataType = OpcUa_Null;
    if (OpcUa_IsGood(OpcUa_EncodeableObject_CreateExtension(&MoxaClassBased_ManagementInterfaceDataType_EncodeableType,
                                                            &extensionObject,
                                                            (OpcUa_Void**)&pManagementInterfaceDataType)))
    {
        MoxaClassBased_ManagementInterfaceDataType_CopyTo(d_ptr, pManagementInterfaceDataType);
    }
}

void ManagementInterfaceDataType::toExtensionObject(UaExtensionObject &extensionObject, OpcUa_Boolean bDetach)
{
    OpcUa_ExtensionObject *pExtensionObject = (OpcUa_ExtensionObject*)(const OpcUa_ExtensionObject*)extensionObject;
    toExtensionObject(*pExtensionObject, bDetach);
}

void ManagementInterfaceDataType::toExtensionObject(OpcUa_ExtensionObject &extensionObject, OpcUa_Boolean bDetach)
{
    OpcUa_ExtensionObject_Clear(&extensionObject);
    MoxaClassBased_ManagementInterfaceDataType *pManagementInterfaceDataType = OpcUa_Null;
    if (OpcUa_IsGood(OpcUa_EncodeableObject_CreateExtension(&MoxaClassBased_ManagementInterfaceDataType_EncodeableType,
                                                            &extensionObject,
                                                            (OpcUa_Void**)&pManagementInterfaceDataType)))
    {
        MoxaClassBased_ManagementInterfaceDataType_Initialize(pManagementInterfaceDataType);
        if (bDetach != OpcUa_False && d_ptr->refCount() == 1)
        {
            *pManagementInterfaceDataType = *d_ptr;
            // clear internal data without releasing deeper memory
            MoxaClassBased_ManagementInterfaceDataType_Initialize(d_ptr);
        }
        else
        {
            MoxaClassBased_ManagementInterfaceDataType_CopyTo(d_ptr, pManagementInterfaceDataType);
        }
        if (bDetach != OpcUa_False)
        {
            d_ptr->release();
            d_ptr = shared_empty_ManagementInterfaceDataType();
            d_ptr->addRef();
        }
    }
}

OpcUa_StatusCode ManagementInterfaceDataType::setManagementInterfaceDataType(const UaExtensionObject &extensionObject)
{
    OpcUa_ExtensionObject *pExtensionObject = (OpcUa_ExtensionObject*)(const OpcUa_ExtensionObject*)extensionObject;
    return setManagementInterfaceDataType(*pExtensionObject);
}

OpcUa_StatusCode ManagementInterfaceDataType::setManagementInterfaceDataType(const OpcUa_ExtensionObject &extensionObject)
{
    OpcUa_StatusCode ret = OpcUa_BadTypeMismatch;
    MoxaClassBased_ManagementInterfaceDataType *pManagementInterfaceDataType = MOXACLASSBASED_EXTENSIONOBJECT_GET_ENCODEABLE(ManagementInterfaceDataType, &extensionObject);

    if (pManagementInterfaceDataType)
    {
        ret = OpcUa_Good;

        if (d_ptr->refCount() == 1)
        {
            MoxaClassBased_ManagementInterfaceDataType_Clear(d_ptr);
        }
        else
        {
            d_ptr->release();
            d_ptr = new ManagementInterfaceDataTypePrivate();
            d_ptr->addRef();
        }

        MoxaClassBased_ManagementInterfaceDataType_CopyTo(pManagementInterfaceDataType, d_ptr);
    }
    return ret;
}

OpcUa_StatusCode ManagementInterfaceDataType::setManagementInterfaceDataType(UaExtensionObject &extensionObject, OpcUa_Boolean bDetach)
{
    OpcUa_ExtensionObject *pExtensionObject = (OpcUa_ExtensionObject*)(const OpcUa_ExtensionObject*)extensionObject;
    return setManagementInterfaceDataType(*pExtensionObject, bDetach);
}

OpcUa_StatusCode ManagementInterfaceDataType::setManagementInterfaceDataType(OpcUa_ExtensionObject &extensionObject, OpcUa_Boolean bDetach)
{
    OpcUa_StatusCode ret = OpcUa_BadTypeMismatch;
    MoxaClassBased_ManagementInterfaceDataType *pManagementInterfaceDataType = MOXACLASSBASED_EXTENSIONOBJECT_GET_ENCODEABLE(ManagementInterfaceDataType, &extensionObject);

    if (pManagementInterfaceDataType != OpcUa_Null)
    {
        ret = OpcUa_Good;

        if (d_ptr->refCount() == 1)
        {
            MoxaClassBased_ManagementInterfaceDataType_Clear(d_ptr);
        }
        else
        {
            d_ptr->release();
            d_ptr = new ManagementInterfaceDataTypePrivate();
            d_ptr->addRef();
        }

        if (bDetach == OpcUa_False)
        {
            MoxaClassBased_ManagementInterfaceDataType_CopyTo(pManagementInterfaceDataType, d_ptr);
        }
        else
        {
            (*(MoxaClassBased_ManagementInterfaceDataType*)d_ptr) = *pManagementInterfaceDataType;
            MoxaClassBased_ManagementInterfaceDataType_Initialize(pManagementInterfaceDataType);
            OpcUa_ExtensionObject_Clear(&extensionObject);
        }
    }
    return ret;
}


bool ManagementInterfaceDataType::isHttpActiveSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpActive) != 0;
}

OpcUa_Boolean ManagementInterfaceDataType::getHttpActive(bool *ok) const
{
    if (ok)
    {
        *ok = isHttpActiveSet();
    }
    return d_ptr->HttpActive;
}

bool ManagementInterfaceDataType::isHttpTcpPortSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpTcpPort) != 0;
}

OpcUa_UInt16 ManagementInterfaceDataType::getHttpTcpPort(bool *ok) const
{
    if (ok)
    {
        *ok = isHttpTcpPortSet();
    }
    return d_ptr->HttpTcpPort;
}

bool ManagementInterfaceDataType::isHttpsActiveSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpsActive) != 0;
}

OpcUa_Boolean ManagementInterfaceDataType::getHttpsActive(bool *ok) const
{
    if (ok)
    {
        *ok = isHttpsActiveSet();
    }
    return d_ptr->HttpsActive;
}

bool ManagementInterfaceDataType::isHttpsTcpPortSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpsTcpPort) != 0;
}

OpcUa_UInt16 ManagementInterfaceDataType::getHttpsTcpPort(bool *ok) const
{
    if (ok)
    {
        *ok = isHttpsTcpPortSet();
    }
    return d_ptr->HttpsTcpPort;
}

bool ManagementInterfaceDataType::isTelnetActiveSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_TelnetActive) != 0;
}

OpcUa_Boolean ManagementInterfaceDataType::getTelnetActive(bool *ok) const
{
    if (ok)
    {
        *ok = isTelnetActiveSet();
    }
    return d_ptr->TelnetActive;
}

bool ManagementInterfaceDataType::isTelnetTcpPortSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_TelnetTcpPort) != 0;
}

OpcUa_UInt16 ManagementInterfaceDataType::getTelnetTcpPort(bool *ok) const
{
    if (ok)
    {
        *ok = isTelnetTcpPortSet();
    }
    return d_ptr->TelnetTcpPort;
}

bool ManagementInterfaceDataType::isSshActiveSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SshActive) != 0;
}

OpcUa_Boolean ManagementInterfaceDataType::getSshActive(bool *ok) const
{
    if (ok)
    {
        *ok = isSshActiveSet();
    }
    return d_ptr->SshActive;
}

bool ManagementInterfaceDataType::isSshTcpPortSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SshTcpPort) != 0;
}

OpcUa_UInt16 ManagementInterfaceDataType::getSshTcpPort(bool *ok) const
{
    if (ok)
    {
        *ok = isSshTcpPortSet();
    }
    return d_ptr->SshTcpPort;
}

bool ManagementInterfaceDataType::isSnmpActiveSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpActive) != 0;
}

MoxaClassBased::ActiveSnmpEnumType ManagementInterfaceDataType::getSnmpActive(bool *ok) const
{
    if (ok)
    {
        *ok = isSnmpActiveSet();
    }
    return d_ptr->SnmpActive;
}

bool ManagementInterfaceDataType::isSnmpTransportProtocolSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpTransportProtocol) != 0;
}

MoxaClassBased::TransportProtocol ManagementInterfaceDataType::getSnmpTransportProtocol(bool *ok) const
{
    if (ok)
    {
        *ok = isSnmpTransportProtocolSet();
    }
    return d_ptr->SnmpTransportProtocol;
}

bool ManagementInterfaceDataType::isSnmpPortSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpPort) != 0;
}

OpcUa_UInt16 ManagementInterfaceDataType::getSnmpPort(bool *ok) const
{
    if (ok)
    {
        *ok = isSnmpPortSet();
    }
    return d_ptr->SnmpPort;
}

bool ManagementInterfaceDataType::isNumberOfHttpAndHttpsLoginSessionsSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_NumberOfHttpAndHttpsLoginSessions) != 0;
}

OpcUa_UInt16 ManagementInterfaceDataType::getNumberOfHttpAndHttpsLoginSessions(bool *ok) const
{
    if (ok)
    {
        *ok = isNumberOfHttpAndHttpsLoginSessionsSet();
    }
    return d_ptr->NumberOfHttpAndHttpsLoginSessions;
}

bool ManagementInterfaceDataType::isNumberOfTelnetAndSshLoginSessionsSet() const
{
    return (d_ptr->EncodingMask & MoxaClassBased_ManagementInterfaceDataType_OptionalFields_NumberOfTelnetAndSshLoginSessions) != 0;
}

OpcUa_UInt16 ManagementInterfaceDataType::getNumberOfTelnetAndSshLoginSessions(bool *ok) const
{
    if (ok)
    {
        *ok = isNumberOfTelnetAndSshLoginSessionsSet();
    }
    return d_ptr->NumberOfTelnetAndSshLoginSessions;
}

void ManagementInterfaceDataType::unsetHttpActive()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->HttpActive = OpcUa_False;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpActive);
}

void ManagementInterfaceDataType::setHttpActive(OpcUa_Boolean HttpActive)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpActive;

    d_ptr->HttpActive = HttpActive;
}

void ManagementInterfaceDataType::unsetHttpTcpPort()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->HttpTcpPort = 0;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpTcpPort);
}

void ManagementInterfaceDataType::setHttpTcpPort(OpcUa_UInt16 HttpTcpPort)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpTcpPort;

    d_ptr->HttpTcpPort = HttpTcpPort;
}

void ManagementInterfaceDataType::unsetHttpsActive()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->HttpsActive = OpcUa_False;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpsActive);
}

void ManagementInterfaceDataType::setHttpsActive(OpcUa_Boolean HttpsActive)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpsActive;

    d_ptr->HttpsActive = HttpsActive;
}

void ManagementInterfaceDataType::unsetHttpsTcpPort()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->HttpsTcpPort = 0;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpsTcpPort);
}

void ManagementInterfaceDataType::setHttpsTcpPort(OpcUa_UInt16 HttpsTcpPort)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_HttpsTcpPort;

    d_ptr->HttpsTcpPort = HttpsTcpPort;
}

void ManagementInterfaceDataType::unsetTelnetActive()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->TelnetActive = OpcUa_False;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_TelnetActive);
}

void ManagementInterfaceDataType::setTelnetActive(OpcUa_Boolean TelnetActive)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_TelnetActive;

    d_ptr->TelnetActive = TelnetActive;
}

void ManagementInterfaceDataType::unsetTelnetTcpPort()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->TelnetTcpPort = 0;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_TelnetTcpPort);
}

void ManagementInterfaceDataType::setTelnetTcpPort(OpcUa_UInt16 TelnetTcpPort)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_TelnetTcpPort;

    d_ptr->TelnetTcpPort = TelnetTcpPort;
}

void ManagementInterfaceDataType::unsetSshActive()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->SshActive = OpcUa_False;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SshActive);
}

void ManagementInterfaceDataType::setSshActive(OpcUa_Boolean SshActive)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SshActive;

    d_ptr->SshActive = SshActive;
}

void ManagementInterfaceDataType::unsetSshTcpPort()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->SshTcpPort = 0;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SshTcpPort);
}

void ManagementInterfaceDataType::setSshTcpPort(OpcUa_UInt16 SshTcpPort)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SshTcpPort;

    d_ptr->SshTcpPort = SshTcpPort;
}

void ManagementInterfaceDataType::unsetSnmpActive()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->SnmpActive = (MoxaClassBased::ActiveSnmpEnumType)0;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpActive);
}

void ManagementInterfaceDataType::setSnmpActive(MoxaClassBased::ActiveSnmpEnumType SnmpActive)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpActive;

    d_ptr->SnmpActive = SnmpActive;
}

void ManagementInterfaceDataType::unsetSnmpTransportProtocol()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->SnmpTransportProtocol = (MoxaClassBased::TransportProtocol)0;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpTransportProtocol);
}

void ManagementInterfaceDataType::setSnmpTransportProtocol(MoxaClassBased::TransportProtocol SnmpTransportProtocol)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpTransportProtocol;

    d_ptr->SnmpTransportProtocol = SnmpTransportProtocol;
}

void ManagementInterfaceDataType::unsetSnmpPort()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->SnmpPort = 0;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpPort);
}

void ManagementInterfaceDataType::setSnmpPort(OpcUa_UInt16 SnmpPort)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_SnmpPort;

    d_ptr->SnmpPort = SnmpPort;
}

void ManagementInterfaceDataType::unsetNumberOfHttpAndHttpsLoginSessions()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->NumberOfHttpAndHttpsLoginSessions = 0;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_NumberOfHttpAndHttpsLoginSessions);
}

void ManagementInterfaceDataType::setNumberOfHttpAndHttpsLoginSessions(OpcUa_UInt16 NumberOfHttpAndHttpsLoginSessions)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_NumberOfHttpAndHttpsLoginSessions;

    d_ptr->NumberOfHttpAndHttpsLoginSessions = NumberOfHttpAndHttpsLoginSessions;
}

void ManagementInterfaceDataType::unsetNumberOfTelnetAndSshLoginSessions()
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }
    d_ptr->NumberOfTelnetAndSshLoginSessions = 0;
    d_ptr->EncodingMask &= (~MoxaClassBased_ManagementInterfaceDataType_OptionalFields_NumberOfTelnetAndSshLoginSessions);
}

void ManagementInterfaceDataType::setNumberOfTelnetAndSshLoginSessions(OpcUa_UInt16 NumberOfTelnetAndSshLoginSessions)
{
    if (d_ptr->refCount() > 1)
    {
        ManagementInterfaceDataTypePrivate *pNew = new ManagementInterfaceDataTypePrivate((const MoxaClassBased_ManagementInterfaceDataType)*d_ptr);
        d_ptr->release();
        d_ptr = pNew;
        d_ptr->addRef();
    }

    d_ptr->EncodingMask |= MoxaClassBased_ManagementInterfaceDataType_OptionalFields_NumberOfTelnetAndSshLoginSessions;

    d_ptr->NumberOfTelnetAndSshLoginSessions = NumberOfTelnetAndSshLoginSessions;
}


/******************************************************************************
** Class ManagementInterfaceDataTypes
******************************************************************************/
ManagementInterfaceDataTypes ManagementInterfaceDataTypes::empty;

ManagementInterfaceDataTypes::ManagementInterfaceDataTypes()
: m_noOfElements(0),
  m_data((MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Null)
{
}

ManagementInterfaceDataTypes::ManagementInterfaceDataTypes(const ManagementInterfaceDataTypes &other)
: m_noOfElements(0),
  m_data((MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Null)
{
    operator=(other);
}

ManagementInterfaceDataTypes::ManagementInterfaceDataTypes(OpcUa_Int32 length, MoxaClassBased_ManagementInterfaceDataType* data)
: m_noOfElements(0),
  m_data((MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Null)
{
    if (length > 0 && data != OpcUa_Null)
    {
        m_noOfElements = length;
        m_data = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Alloc(m_noOfElements * sizeof(MoxaClassBased_ManagementInterfaceDataType));
        for (OpcUa_UInt32 i = 0; i < m_noOfElements; i++)
        {
            MoxaClassBased_ManagementInterfaceDataType_CopyTo(&(data[i]), &(m_data[i]));
        }
    }
}

ManagementInterfaceDataTypes::~ManagementInterfaceDataTypes()
{
    clear();
}

ManagementInterfaceDataTypes& ManagementInterfaceDataTypes::operator=(const ManagementInterfaceDataTypes &other)
{
    if (this == &other) {return *this;}

    clear();
    if (other.m_noOfElements > 0)
    {
        m_noOfElements = other.m_noOfElements;
        m_data = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Alloc(m_noOfElements * sizeof(MoxaClassBased_ManagementInterfaceDataType));
        for (OpcUa_UInt32 i = 0; i < m_noOfElements; i++)
        {
            MoxaClassBased_ManagementInterfaceDataType_CopyTo(&(other.m_data[i]), &(m_data[i]));
        }
    }
    return *this;
}

/** Returns the MoxaClassBased_ManagementInterfaceDataType at index position index as a modifiable reference.
 *
 *  index must be valid index position in the array.
 */
MoxaClassBased_ManagementInterfaceDataType& ManagementInterfaceDataTypes::operator[](OpcUa_UInt32 index)
{
    assert(index<m_noOfElements);
    return m_data[index];
}

/** Returns the MoxaClassBased_ManagementInterfaceDataType at index position index.
 *
 *  index must be valid index position in the array.
 */
const MoxaClassBased_ManagementInterfaceDataType& ManagementInterfaceDataTypes::operator[](OpcUa_UInt32 index) const
{
    assert(index<m_noOfElements);
    return m_data[index];
}

/** Attaches the raw data.
 *
 *  Clears the array and takes the ownership of data.
 *  Don't clear the data afterwards manually, because ManagementInterfaceDataTypes is responsible for it now.
 */
void ManagementInterfaceDataTypes::attach(OpcUa_UInt32 length, MoxaClassBased_ManagementInterfaceDataType* data)
{
    clear();
    m_data = data;
    m_noOfElements = length;
}

/** Attaches the raw data.
 *
 *  Clears the array and takes the ownership of data.
 *  Don't clear the data afterwards manually, because ManagementInterfaceDataTypes is responsible for it now.
 */
void ManagementInterfaceDataTypes::attach(OpcUa_Int32 length, MoxaClassBased_ManagementInterfaceDataType* data)
{
    clear();
    if (length >= 0)
    {
        m_data = data;
        m_noOfElements = length;
    }
}

bool ManagementInterfaceDataTypes::operator==(const ManagementInterfaceDataTypes &other) const
{
    if (m_noOfElements != other.m_noOfElements) {return false;}

    if (m_noOfElements > 0)
    {
        for (OpcUa_UInt32 i = 0; i < m_noOfElements; i++)
        {
            if (MoxaClassBased_ManagementInterfaceDataType_Compare(&(m_data[i]), &(other.m_data[i])) != OPCUA_EQUAL) {return false;};
        }
    }
    return true;
}

bool ManagementInterfaceDataTypes::operator!=(const ManagementInterfaceDataTypes &other) const
{
    return !(operator==(other));
}

/** Detaches the raw data from this class.
 *
 *  The caller takes ownership of the raw data and is responsible for deleting it
 *  by calling OpcUa_Free.
 *  @return The raw data.
 */
MoxaClassBased_ManagementInterfaceDataType* ManagementInterfaceDataTypes::detach()
{
    MoxaClassBased_ManagementInterfaceDataType* pRet = m_data;
    m_noOfElements = 0;
    m_data = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Null;
    return pRet;
}

void ManagementInterfaceDataTypes::create(OpcUa_UInt32 length)
{
    clear();
    if (length > 0)
    {
        m_data = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Alloc(length * sizeof(MoxaClassBased_ManagementInterfaceDataType));
        for (OpcUa_UInt32 i = 0; i < length; i++)
        {
            MoxaClassBased_ManagementInterfaceDataType_Initialize(&(m_data[i]));
        }
        m_noOfElements = length;
    }
}

void ManagementInterfaceDataTypes::resize(OpcUa_UInt32 length)
{
    if (length < m_noOfElements)
    {
        if (length != 0)
        {
            for (OpcUa_UInt32 i = length; i < m_noOfElements; i++)
            {
                MoxaClassBased_ManagementInterfaceDataType_Clear(&(m_data[i]));
            }

            MoxaClassBased_ManagementInterfaceDataType* newData = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_ReAlloc(m_data, length * sizeof(MoxaClassBased_ManagementInterfaceDataType));
            if (newData)
            {
                m_data = newData;
                m_noOfElements = length;
            }
        }
        else
        {
            clear();
        }
    }
    else if (length > m_noOfElements)
    {
        MoxaClassBased_ManagementInterfaceDataType* newData = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_ReAlloc(m_data, length * sizeof(MoxaClassBased_ManagementInterfaceDataType));
        if (newData)
        {
            for (OpcUa_UInt32 i = m_noOfElements; i < length; i++)
            {
                MoxaClassBased_ManagementInterfaceDataType_Initialize(&(newData[i]));
            }
            m_data = newData;
            m_noOfElements = length;
        }
    }
}

void ManagementInterfaceDataTypes::clear()
{
    if (m_data)
    {
        for (OpcUa_UInt32 i = 0; i < m_noOfElements; i++)
        {
            MoxaClassBased_ManagementInterfaceDataType_Clear(&(m_data[i]));
        }
        OpcUa_Free(m_data);
        m_data = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Null;
    }
    m_noOfElements = 0;
}

void ManagementInterfaceDataTypes::toVariant(UaVariant &variant) const
{
    OpcUa_Variant *pVariant = (OpcUa_Variant*)(const OpcUa_Variant*)variant;
    toVariant(*pVariant);
}

void ManagementInterfaceDataTypes::toVariant(OpcUa_Variant &variant) const
{
    OpcUa_Variant_Clear(&variant);

    variant.Datatype = OpcUaType_ExtensionObject;
    variant.ArrayType = OpcUa_VariantArrayType_Array;
    variant.Value.Array.Length = m_noOfElements;
    variant.Value.Array.Value.ExtensionObjectArray = (OpcUa_ExtensionObject*)OpcUa_Alloc(m_noOfElements * sizeof(OpcUa_ExtensionObject));
    for (OpcUa_UInt32 i = 0; i < m_noOfElements; i++)
    {
        MoxaClassBased_ManagementInterfaceDataType *pValue = OpcUa_Null;
        OpcUa_ExtensionObject_Initialize(&variant.Value.Array.Value.ExtensionObjectArray[i]);
        OpcUa_EncodeableObject_CreateExtension(&MoxaClassBased_ManagementInterfaceDataType_EncodeableType,
                                               &variant.Value.Array.Value.ExtensionObjectArray[i],
                                               (OpcUa_Void**)&pValue);
        MoxaClassBased_ManagementInterfaceDataType_CopyTo(&m_data[i], pValue);
    }
}

void ManagementInterfaceDataTypes::toVariant(UaVariant &variant, OpcUa_Boolean bDetach)
{
    OpcUa_Variant *pVariant = (OpcUa_Variant*)(const OpcUa_Variant*)variant;
    toVariant(*pVariant, bDetach);
}

void ManagementInterfaceDataTypes::toVariant(OpcUa_Variant &variant, OpcUa_Boolean bDetach)
{
    OpcUa_Variant_Clear(&variant);
    variant.Datatype = OpcUaType_ExtensionObject;
    variant.ArrayType = OpcUa_VariantArrayType_Array;
    variant.Value.Array.Length = m_noOfElements;
    variant.Value.Array.Value.ExtensionObjectArray = (OpcUa_ExtensionObject*)OpcUa_Alloc(m_noOfElements * sizeof(OpcUa_ExtensionObject));
    for (OpcUa_UInt32 i = 0; i < m_noOfElements; i++)
    {
        MoxaClassBased_ManagementInterfaceDataType *pValue = OpcUa_Null;
        OpcUa_ExtensionObject_Initialize(&variant.Value.Array.Value.ExtensionObjectArray[i]);
        OpcUa_EncodeableObject_CreateExtension(&MoxaClassBased_ManagementInterfaceDataType_EncodeableType,
                                               &variant.Value.Array.Value.ExtensionObjectArray[i],
                                               (OpcUa_Void**)&pValue);
        if (bDetach != OpcUa_False)
        {
            *pValue = m_data[i];
        }
        else
        {
            MoxaClassBased_ManagementInterfaceDataType_CopyTo(&m_data[i], pValue);
        }
    }
    if (bDetach != OpcUa_False)
    {
        OpcUa_Free(m_data);
        m_data = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Null;
        m_noOfElements = 0;
    }
}

void ManagementInterfaceDataTypes::toDataValue(UaDataValue &dataValue, OpcUa_Boolean updateTimeStamps) const
{
    UaVariant variant;
    toVariant(variant);
    dataValue.setValue(variant, OpcUa_True, updateTimeStamps);
}

void ManagementInterfaceDataTypes::toDataValue(OpcUa_DataValue &dataValue, OpcUa_Boolean updateTimeStamps) const
{
    toVariant(dataValue.Value);

    if (updateTimeStamps != OpcUa_False)
    {
        dataValue.SourceTimestamp = OpcUa_DateTime_UtcNow();
        dataValue.ServerTimestamp = dataValue.SourceTimestamp;
    }
}

void ManagementInterfaceDataTypes::toDataValue(UaDataValue &dataValue, OpcUa_Boolean bDetach, OpcUa_Boolean updateTimeStamps)
{
    UaVariant variant;
    toVariant(variant, bDetach);
    dataValue.setValue(variant, OpcUa_True, updateTimeStamps);
}

void ManagementInterfaceDataTypes::toDataValue(OpcUa_DataValue &dataValue, OpcUa_Boolean bDetach, OpcUa_Boolean updateTimeStamps)
{
    toVariant(dataValue.Value, bDetach);

    if (updateTimeStamps != OpcUa_False)
    {
        dataValue.SourceTimestamp = OpcUa_DateTime_UtcNow();
        dataValue.ServerTimestamp = dataValue.SourceTimestamp;
    }
}

OpcUa_StatusCode ManagementInterfaceDataTypes::setManagementInterfaceDataTypes(const UaVariant &variant)
{
    OpcUa_Variant *pVariant = (OpcUa_Variant*)(const OpcUa_Variant*)variant;
    return setManagementInterfaceDataTypes(*pVariant);
}

OpcUa_StatusCode ManagementInterfaceDataTypes::setManagementInterfaceDataTypes(const OpcUa_Variant &variant)
{
    return setManagementInterfaceDataTypes((OpcUa_Variant&)variant, OpcUa_False);
}

OpcUa_StatusCode ManagementInterfaceDataTypes::setManagementInterfaceDataTypes(UaVariant &variant, OpcUa_Boolean bDetach)
{
    OpcUa_Variant *pVariant = (OpcUa_Variant*)(const OpcUa_Variant*)variant;
    return setManagementInterfaceDataTypes(*pVariant, bDetach);
}

OpcUa_StatusCode ManagementInterfaceDataTypes::setManagementInterfaceDataTypes(OpcUa_Variant &variant, OpcUa_Boolean bDetach)
{
    clear();

    OpcUa_StatusCode ret = OpcUa_BadTypeMismatch;
    if (variant.Datatype == OpcUaType_ExtensionObject &&
        variant.ArrayType == OpcUa_VariantArrayType_Array)
    {
        ret = OpcUa_Good;
        m_noOfElements = variant.Value.Array.Length >= 0 ? variant.Value.Array.Length : 0;
        if (m_noOfElements > 0 && variant.Value.Array.Value.ExtensionObjectArray != OpcUa_Null)
        {
            m_data = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Alloc(m_noOfElements * sizeof(MoxaClassBased_ManagementInterfaceDataType));

            OpcUa_UInt32 i = 0;
            for (i = 0; i < m_noOfElements; i++)
            {
                MoxaClassBased_ManagementInterfaceDataType_Initialize(&m_data[i]);

                MoxaClassBased_ManagementInterfaceDataType *pValue = MOXACLASSBASED_EXTENSIONOBJECT_GET_ENCODEABLE(ManagementInterfaceDataType, &variant.Value.Array.Value.ExtensionObjectArray[i]);
                if (pValue)
                {
                    if (bDetach != OpcUa_False)
                    {
                        m_data[i] = *pValue;
                        MoxaClassBased_ManagementInterfaceDataType_Initialize(pValue);
                    }
                    else
                    {
                        MoxaClassBased_ManagementInterfaceDataType_CopyTo(pValue, &m_data[i]);
                    }
                }
                else
                {
                    ret = OpcUa_BadTypeMismatch;
                    break;
                }
            }
            if (OpcUa_IsNotGood(ret))
            {
                for (OpcUa_UInt32 j = 0; j < i; j++)
                {
                    MoxaClassBased_ManagementInterfaceDataType_Clear(&m_data[j]);
                }
                OpcUa_Free(m_data);
                m_data = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Null;
                m_noOfElements = 0;
            }
        }
        else
        {
            m_noOfElements = 0;
        }
    }
    return ret;
}

OpcUa_StatusCode ManagementInterfaceDataTypes::setManagementInterfaceDataTypes(OpcUa_Int32 length, MoxaClassBased_ManagementInterfaceDataType* data)
{
    clear();

    if (length > 0 && data != OpcUa_Null)
    {
        m_noOfElements = length;
        m_data = (MoxaClassBased_ManagementInterfaceDataType*)OpcUa_Alloc(m_noOfElements * sizeof(MoxaClassBased_ManagementInterfaceDataType));
        for (OpcUa_UInt32 i = 0; i < m_noOfElements; i++)
        {
            MoxaClassBased_ManagementInterfaceDataType_CopyTo(&(data[i]), &(m_data[i]));
        }
    }
    return OpcUa_Good;
}

} // namespace MoxaClassBased

